<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="RBlog">
<meta property="article:author" content="Ryan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>RBlog</title>
  








<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/" itemprop="url">2.计算机基础/c.操作系统/9.单处理器调度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><font face="fangsong"> <font size="6">第九章：单处理器调度</font> <font size="4"></font></font></p>
<h1 id="处理器调度的类型">1、处理器调度的类型</h1>
<h2 id="三种类型之间的联系">1.1、三种类型之间的联系</h2>
<p><b>1. 比较三种调度</b></p>
<p><a href="https://en.wikipedia.org/wiki/Scheduling_(computing)#Long-term_scheduling" target="_blank" rel="noopener">reference</a></p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">调度类型</th>
<th style="text-align: left;">简介</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">长程调度</td>
<td style="text-align: left;">  1、决定外存上处于后备队列中的进程是否加入待执行进程池（就绪队列），并为它们创建进程、分配必要的资源，排入就绪队列。<br>  2、长程调度的目标在于协调I/O密集型程序与计算密集型程序的比例，提高系统并发度。</td>
</tr>
<tr class="even">
<td style="text-align: left;">中程调度</td>
<td style="text-align: left;">  决定待执行线程池中位于内存中的进程集合，决定把哪些进程挂起并从内存交换到外存，又在适当时机把挂起进程激活并重新调入内存，降低程序多道度。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">短程调度</td>
<td style="text-align: left;">  决定处理器执行就绪队列中的哪一个进程，是操作系统最基本的调度</td>
</tr>
</tbody>
</table>
<p><b>2. 七状态模型</b> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/三种调度关系.png%22"></p>
<p><b>3. 调度本质上是队列管理</b> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/队列调度.png%22"></p>
<h1 id="调度算法">2、调度算法</h1>
<h2 id="短程调度准则">2.1、短程调度准则</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/调度规则总览.png%22"></p>
<ul>
<li>面向用户
<ul>
<li>与性能相关
<ul>
<li>周转时间:指一个进程从提交到完成之间的时间间隔,包括实际执行时间加上等待资源(包括处理器资源)的时间。对批处理作业而言、这是一种很适宜的度量</li>
<li>响应时间:对一个交互进程,这是指从提交一个请求到开始接收响应之间的时间间隔。運常进程在处理该请求的同时,就开始给用户产生一些输出。因此从用户户的角度来看,相对于周转时间,这是一种更好的度量。该调度原则应该试图达到较低的响应时间,并且在响应时间可接受的范围内,使得可以交互的用户的数目达到最大</li>
<li>最后期限：当可以指定进程完成的最后期限时,调度原则将降低其他目标,使得满足最后期限的作业数目的百分比达到最大</li>
</ul></li>
<li>其他
<ul>
<li>可预测性：无论系统的负载如何,一个给定的工作运行的总时间量和总代价是相同的。用户不希望响应时间或闹转时间的变化太大。这可能需要在系统工作负载大范抖动时发出信号或者要系统处理不稳定性</li>
</ul></li>
</ul></li>
<li>面向系统
<ul>
<li>与性能相关
<ul>
<li>吞吐量：调度策略应该试图使得每个单位时间内完成的进程数目达到最大。这是对可以执行多少工作的一种度量。它明显取决于一个进程的平均执行长度,也受调度策略的影响,调度策略会影响利用率</li>
<li>处理器利用率:这是处理器处于忙的状态的时间百分比。对昂贵的共享系统来说,这是一个重要的准则。在单用户系统和一些其他的系统如实时系统中,该准则与其他准则相比显得不太重要</li>
</ul></li>
<li>其他
<ul>
<li>公平性：在没有来自用户的指导或其他系统提供的指导时,进应该被平等地对待,没有一个进程会处于饥饿状态</li>
<li>强制优先级：当进程被指定了优先級后,调度策应该优先选择高优先级的进程</li>
<li>平衡资源：调度策略将保持系统中所有资源处于忙状态,较少使用紧缺资源的进程应该受到照顾。该准则也可用于中程调度和长程调度</li>
</ul></li>
</ul></li>
</ul>
<h2 id="优先级使用">2.2、优先级使用</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/优先级排队.png%22"></p>
<p>  通过指数衰减的方式来更新各个队列的优先级，否则很可能会出现饥饿的现象。</p>
<h2 id="选择调度策略">2.3、选择调度策略</h2>
<h3 id="种调度策略">2.3.1、7种调度策略</h3>
<ul>
<li>决策模式
<ul>
<li>抢占:
<ul>
<li>在这种情况下,一旦进程处于运行状态,它就不断执行直到终止,或者因为等待IO或者因而请求某些操作系统服务而阻塞自己。</li>
<li>可能会导致较大的开销,但是可能会对所有进程提供较好的服务，因为其避免了任何一个进程独占处理器太长时间。</li>
<li><font color="red">抢占是指抢占处理器资源。</font></li>
</ul></li>
<li>非抢占：
<ul>
<li>当前正在运行的进程可能被操作系统中断,并转移到就绪态。关于抢占的决策可能是在一个新进程到达时,或者在个中断发生后,把一个被阻塞的进程置为就绪态时,或者出现基于周期性的时间中断时。</li>
</ul></li>
</ul></li>
</ul>
<ol type="1">
<li>先来先服务（FCFS），即是FIFO排队方案。</li>
<li><font color="green">轮转（RR）</font>
<ul>
<li>基于时钟的抢占策略中最简单的方案，主要的设计问题是时间片的长度。
<ul>
<li>时间片过短时，进程切换的时间占用比例比较高，处理器效率比较低。</li>
<li><font color="red">当一个时间片比运行时间最长的进程还要长时，轮转法就会退化成FCFS算法。</font></li>
</ul></li>
<li>优点
<ul>
<li>轮转法在通用的分时系统或事务处理系统中特别有效</li>
</ul></li>
<li>缺点
<ul>
<li>处理器密集型进程不公平（处理器密集型进程占用处理器时间大大多于I/O密集型进程）的使用了大部分处理器时间，导致I/O密集型进程性能降低，使用I/O设备低效，响应时间变化较大。</li>
</ul></li>
</ul></li>
<li><font color="green">虚拟轮转（VRR）</font>
<ul>
<li>引入优先级，解除了I/O阻塞的进程都会转移到一个FCFS辅助队列中，该队列优先级高于就绪队列。</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/VRR排队图.png%22"></li>
</ul></li>
<li><font color="blue">最短进程优先（SPN:Shortest Process Next）</font>
<ul>
<li><font color="red">当前进程阻塞或完成时</font>，选择预计处理时间最短的进程，短进程将会越过长进程跳到队列头。</li>
<li>估计进程处理时间
<ul>
<li>批处理作业：程序员估计，将结果告知操作系统。如果估值远远低于实际运行时间，操作系统就可能终止该作业。</li>
<li>交互进程：相同的作业会频繁地运行，系统为每个进程保留一个运行平均值。
<ul>
<li>简单平均：<span class="math inline">\(S_{n+1}=\dfrac{1}{n}T_n+\dfrac{n-1}{n}S_{n}=\dfrac{1}{n}\sum\limits_{i=1}^{n}{T_i}\)</span></li>
<li>指数平均法：<span class="math inline">\(S_{n+1}=\alpha T_{n}+(1-\alpha)S_{n}\)</span>
<ul>
<li>各项比例和为<span class="math inline">\(\alpha \sum\limits_{i=0}^{n-1}{(1-\alpha)^i}+(1-\alpha)^n=1\)</span>。</li>
<li><span class="math inline">\(\alpha\)</span>取值越大，平均值越能反映观测值的快速变化，波动越大；反之<span class="math inline">\(\alpha\)</span>取值越小，波动越小。</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/alpha不同取值下的观测值变化.png%22"></li>
</ul></li>
</ul></li>
</ul></li>
<li>缺点
<ul>
<li>长进程可能饥饿。</li>
<li>虽然降低了对长作业的偏向，但是缺少抢占机制，在分时系统或事务处理环境下仍不理想。</li>
</ul></li>
</ul></li>
<li><font color="blue">最短剩余时间优先（SRT：Shortest Remaining Time）</font>
<ul>
<li>是在SPN中增加了抢占机制的选择策略，<font color="red">当一个新进程加入时，选择从处理器当前状态到一个进程执行完所用时间最小的进程进行执行</font>。</li>
<li>SPN是评价一个进程整体执行完所用时间；SRT评价从处理器当前状态到一个进程执行完所用时间。</li>
<li>SRT也具有长进程饥饿的风险。</li>
</ul></li>
<li><font color="blue">最高响应比优先（HRRN：Highest Response Ratio Next）</font>
<ul>
<li><span class="math inline">\(R=\dfrac{w+s}{s}\)</span>，<font color="red">当前进程完成或被阻塞时</font>，选择R最大的进程进行执行。</li>
<li>该方案解决了SPN和SRT方案中的长进程饥饿的隐患——长进程等待时间不断增加，导致R增大，最终优先级升高。</li>
<li><span class="math inline">\(R \geqslant 1\)</span>，只有第一个进入系统的进程才能达到该值。</li>
</ul></li>
<li><font color="purple">反馈法（FB：Feedback）</font>
<ul>
<li>通过处罚运行时间较长的作业来达到优先考虑短作业的目的。
<ul>
<li><span class="math inline">\(q=1\)</span>：每个队列中的时间片都是<span class="math inline">\(1\)</span></li>
<li><span class="math inline">\(q=2^i\)</span>：第<span class="math inline">\(i\)</span>个队列中的时间片是<span class="math inline">\(2^i\)</span>（也可以没有这一特点，但是带来的后果是长进程执行时间将会惊人地增加）。</li>
</ul></li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/反馈调度.png%22"></li>
<li>缺点
<ul>
<li>新作业频繁进入系统时，长进程老进程可能会出现饥饿的情况。</li>
</ul></li>
<li>改进方案
<ul>
<li>当一个进程在其当前队列中等待服务的时间超过一定时间后，就将它提升到优先级较高的一个队列中。</li>
</ul></li>
</ul></li>
</ol>
<h3 id="总结">2.3.2、总结</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">符号</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">w(wait)</td>
<td style="text-align: left;">到现在为止,在系统中t停留的时间</td>
</tr>
<tr class="even">
<td style="text-align: left;">e(expense)</td>
<td style="text-align: left;">到现在为止，花费的执行时间</td>
</tr>
<tr class="odd">
<td style="text-align: left;">s(serve)</td>
<td style="text-align: left;">估计的该进程需要的总服务时间</td>
</tr>
</tbody>
</table>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/各种调度策略的特点.png%22"></p>
<h3 id="示例">2.3.3、示例</h3>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/调度示例表.png%22"> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/调度示例图.png%22"></p>
<h2 id="性能比较">2.4、性能比较</h2>
<h3 id="排队分析">2.4.1、排队分析</h3>
<h3 id="仿真建模">2.4.2、仿真建模</h3>
<h2 id="公平共享制度">2.5、公平共享制度</h2>
<h1 id="传统的unix调度">3、传统的UNIX调度</h1>
<h1 id="参考">4、参考</h1>
<ul>
<li>https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/5_CPU_Scheduling.html</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" itemprop="url">2.计算机基础/c.操作系统/8.虚拟内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="硬件和控制结构">1、硬件和控制结构</h1>
<h2 id="局部性原理">1.1、局部性原理</h2>
<p>可参考超算课件4 - 时间局部性 - 空间局部性</p>
<h2 id="分页">1.2、分页</h2>
<h3 id="纲要">1.2.1、纲要</h3>
<ul>
<li>分页
<ul>
<li>一级页表</li>
<li>两级页表
<ul>
<li>多级页表如何划分不同的level？（应运用整体性思想进行分析）</li>
</ul></li>
<li>倒排页表
<ul>
<li>线性倒排页表</li>
<li>散列倒排页表</li>
</ul></li>
<li>转换检测缓冲区/快表（TLB：translation lookaside buffer）
<ul>
<li>关联映射：可同时查询多项</li>
<li>TLB是全关联的（from计组）</li>
<li>提升性能的方法
<ul>
<li>扩大TLB大小</li>
<li>增大页尺寸</li>
</ul></li>
</ul></li>
</ul></li>
<li>分段</li>
<li>段页式</li>
</ul>
<p>  <font color="red">在虚存中，地址的转换变得更加复杂：逻辑地址（虚拟页号+offset）-&gt;伪物理地址（本地页号+offset）-&gt;物理地址（页框好+offset）。</font></p>
<h3 id="一级分页">1.2.2、一级分页</h3>
<p>  只采用分页的虚拟地址结构如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/分页地址结构.png%22">   虚拟地址通过查表转换成物理地址： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/一级分页地址转换.png%22"></p>
<h3 id="二级分页">1.2.3、二级分页</h3>
<p>  采用二级分页的虚拟地址结构与一级分页的一样，区别在于二级分页对其虚拟页号再次进行了划分： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/二级分页简单示意.png%22">   虚拟地址通过查两次表转换成物理地址： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/二级分页地址转换.png%22"></p>
<h3 id="倒排页表">1.2.4、倒排页表</h3>
<p>  <a href="E:\课_操作系统\virtual_memory4.pdf">参考资料</a></p>
<p>  散列倒排页表的转换简化过程如下（散列-存取数据规则一致）： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/倒排页表地址转换.png%22"></p>
<p>  倒排页表也有两种：一种是线性倒排页表，另一种则是哈希倒排列表，上图是哈希倒排列表的结构图。线性倒排列表的结构比较简单，可以认为申请了一块比较大的空间用来存储线性倒排列表，其中的条目数为<span class="math inline">\(2^{\text{length_of_VPN}}\)</span>。这样可能消耗的空间会比较多，哈希倒排列表则减少了空间的消耗（类似直接下标查找和哈希查找）。</p>
<h3 id="tlb">1.2.5、TLB</h3>
<p>  使用了TLB的分页机制的虚拟地址转换成物理地址的过程如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/TLB地址转换.png%22">   通过使用关联技术可以提高TLB查找的速度： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/TLB关联.png%22">   总体的流程如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/有TLB的访问流程.png%22"></p>
<h2 id="分段">1.3、分段</h2>
<p>  与单级分页很像，其虚拟地址结构如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/分段地址结构.png%22">   虚拟地址转换成物理地址的过程如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/分段地址转换.png%22"></p>
<h2 id="段页式">1.4、段页式</h2>
<p>  虚拟地址结构如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/段页式地址结构.png%22">   虚拟地址转换成物理地址的过程如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/段页式地址转换.png%22"></p>
<h2 id="保护和共享">1.5、保护和共享</h2>
<h1 id="操作系统的内存管理设计">2、操作系统的内存管理设计</h1>
<p>  操作系统的内存管理设计取决于三个基本的选择（前二者取决于硬件平台）： - 是否使用虚存技术 - 分页 or 分段 or 段页式？ - 为各种存储管理特征采用的算法 ## 2.1、读取策略 - <font color="red">请求分页</font>：只有当访问到某页的一个单元时才将该页取入内存 - <font color="red">预先分页</font>：利用空间局部性原理与辅存设备的特性（连续取可降低单页取入时间）</p>
<p>  进程首次启动时，应采用预先分页的读取策略。</p>
<h2 id="放置策略">2.2、放置策略</h2>
<p>  第七章中有提到： - <font color="red">最佳适配</font> - <font color="red">首次适配</font> - <font color="red">下次适配</font></p>
<p>  <font color="red">纯分页或段页式系统中放置策略并不重要</font>，因为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能。<br>   在NUMA（非一致存储访问）系统中放置策略则比较重要，因为其性能很大程度上取决于数据驻留的位置与使用数据的处理器间的距离，所以自动防治策略希望能把页分配到能够提供最佳性能的内存位置。</p>
<h2 id="置换策略">2.3、置换策略</h2>
<p>  目标：移出最近最不可能访问的页。 &gt; 页框锁定：内存中的某些页框可能是被锁定的。大部分操作系统内核和重要的控制结构就保存在锁定的页框中。一个页框被锁定时，当前保存在该页框中的页就不能被置换。</p>
<h3 id="基本算法">2.3.1、基本算法</h3>
<p>  基本算法有如下几种： - OPT - LRU - FIFO - Clock</p>
<blockquote>
<p>最佳置换策略（Optimal，OPT）</p>
</blockquote>
<p>  置换下次访问距当前时间最长的那些页，这种算法导致的缺页中断最少，但是需要知道未来发生的事件，故而是<font color="red">不可能实现</font>的，只能作为性能评估的参考。</p>
<blockquote>
<p>最近最少使用（Least-Recently-Used，LRU）</p>
</blockquote>
<p>  置换内存中最长时间未被引用的页。性能接近OPT，但是<font color="red">开销很大</font>。</p>
<p>  实现方案： - 方案1：维护一个关于访问页的栈 - 方案2：给每页添加一个时间戳 - 方案3：移位计数器</p>
<blockquote>
<p>先进先出（FIFO）</p>
</blockquote>
<p>  是最简单的置换策略，隐含的逻辑是置换驻留在内存中时间最长的页（这一推断通常是错误的）。 &gt; 时钟置换策略（Clock）</p>
<p>  是一种折中方案，试图用较小的开销取得接近LRU的性能。用一个情景来描述：一圈立着的木牌，开始的时候都是倒着的(value=0)，一个人从开始位置起，每收到一个指令（要新加一页），他就往前走，找到第一个倒着的木牌，把它竖起来，表示目标找到。<font color="red">在此过程中，它途径路上所有竖着的木牌都会被他放倒</font>。</p>
<p>  可以通过伪代码来理解其过程： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pagearr[N] &#x3D; &#123;N pages&#125;</span><br><span class="line">pagearr[*].usebit &#x3D; 0</span><br><span class="line">ptr &#x3D; pagearr</span><br><span class="line"></span><br><span class="line">if hit:</span><br><span class="line">    *ptr.usebit &#x3D; 1</span><br><span class="line">else:</span><br><span class="line">    # 从当前指针位置开始，找到一个合题意的页（或许有内容，或许为空）进行置换</span><br><span class="line">    while (access page):</span><br><span class="line">        if (*ptr.usebit &#x3D; 0):</span><br><span class="line">            load page</span><br><span class="line">            *ptr.usebit &#x3D; 1</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            *ptr.usebit &#x3D; 0</span><br><span class="line">            ptr++</span><br><span class="line">    ptr++</span><br></pre></td></tr></table></figure></p>
<p>  * 通过增加使用的位数可以使时钟算法更有效。</p>
<blockquote>
<p>例题 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/置换策略例题.png%22"></p>
</blockquote>
<h3 id="页缓冲">2.3.2、页缓冲</h3>
<ul>
<li>空闲页链表</li>
<li>修改页链表</li>
</ul>
<h2 id="清除策略">2.4、清除策略</h2>
<p>  与读取策略相反，清除策略决定何时将已修改的一页写回辅存。 - 请求式清除：只有当一页被置换时才被写回辅存。 - 预约式清除：将已修改的多页在需要时他们所占据的页框之前成批地写回辅存。</p>
<p>  <font color="red">结合页缓冲技术可以允许如下策略：只清除可用于置换的页，但去除了清除和置换操作间的成对关系。</font></p>
<h2 id="驻留集管理">2.5、驻留集管理</h2>
<h3 id="基本方面">2.5.1、基本方面</h3>
<p><b>驻留集大小</b></p>
<p><b>分配策略</b> - 固定分配策略 - 可变分配策略</p>
<p><b>置换范围</b> - 局部置换策略 - 全局置换策略</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">   局部置换</th>
<th style="text-align: left;">  全局置换</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
固定分配 |
<ul>
<li>
分配给一个进程的页框数是固定的
</li>
<li>
从分配给该进程的页框中选择被置换的页
</li>
</ul>
|   不存在 可变分配 |
<ul>
<li>
分配给一个进程的页框数不时发生变化
</li>
<li>
从分配给该进程的页框中选择被置换的页
</li>
</ul>
|
<ul>
<li>
从内存中的所有可用页框中选择被置换的页，这导致进程驻留集大小不断改变
</li>
</ul>
<p><b>固定分配、局部范围</b> - 优点 - 缺点 - 总页数若分配过少，将产生很高的缺页率 - 总页数分配过多，内存中只能有很少的几个程序</p>
<p><b>可变分配、全局范围</b> - 优点 - 最容易实现 - 缺点 - 难点在于置换页的选择（没有空闲页框时） - 改进 - 使用页缓冲，此时选择置换哪一页不重要，因为如果下一次重写这些页之前访问到了被替换的页，该页可以回收。</p>
<p><b>可变分配、局部范围</b> - 过程总结 - 优点 - 性能较好 - 缺点 - 实现比“可变分配、全局范围”复杂得多</p>
<h3 id="工作集策略隶属于可变分配局部范围">2.5.2、工作集策略（隶属于可变分配、局部范围）</h3>
<p><b>理想化的工作集策略（<font color="red">理想情况下工作集=驻留集</font>）</b></p>
<blockquote>
<p>相关变量： - 工作集W：（当前活跃）页的集合 - 虚拟时间t：推测——<span class="math inline">\(t\in[0,\Delta]\)</span>时，t++且W++，当<span class="math inline">\(t=\Delta\)</span>时，清除没有用过的页。 - 虚拟时间窗口<span class="math inline">\(\Delta\)</span>：虚拟窗口越大，工作集就越大（<span class="math inline">\(W_{max}(t,\Delta+1)&gt; W_{max}(t,\Delta)\)</span>） - 进程页数N：<span class="math inline">\(1\leqslant W(t,\Delta) \leqslant min\{\Delta,N\}\)</span>，前<span class="math inline">\(N\)</span>次全部缺失的时候右边等号成立。</p>
</blockquote>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/理想化工作集策略示例.png%22"><br>理想化工作集策略示例</p>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/工作集大小的典型图形.png%22"><br>工作集大小的典型图形</p>
<p>  从上图可以看出： - 稳定状态 <span class="math inline">\(\iff\)</span> 进程进入局部性阶段 - 瞬变状态 <span class="math inline">\(\iff\)</span> 进程转移到新的局部性阶段</p>
<p>  工作集策略可以指导有关驻留集大小的策略： - <font color="red">进程全集 <span class="math inline">\(\supseteq\)</span> 驻留集 <span class="math inline">\(\supseteq\)</span> 工作集</font> - 监视每个进程的工作集。 - 周期性地从一个进程的驻留集中移去那些不在其工作集中的页（<font color="red">工作集 <span class="math inline">\(\neq\)</span> 驻留集</font>）。 - 只有当一个进程的工作集在内存中（即其驻留集 <span class="math inline">\(\supseteq\)</span> 工作集）时，才可执行该进程。</p>
<p>  工作集策略存在的问题： - 根据过去并不总能预测未来 - 为每个进程真实地测量工作集是不实际的 - <span class="math inline">\(\Delta\)</span>的最优值是未知的，且它在任何情况下都会变化</p>
<p><b>缺页中断频率（PFF）算法</b></p>
<p>  定义一个阈值F（通过虚拟时间来表示缺页率），如果从上一次缺页中断到这次缺页中断的时间小于F（缺页率太高了），则把该页加到该进程的驻留集中；否则淘汰所有使用位为0的页，缩减驻留集大小。</p>
<p>  还可以使用两个时间阈值对该算法进行改进：定义低时间阈值<span class="math inline">\(F_{min}\)</span>/<span class="math inline">\(f_{max}\)</span>（用于引发驻留集大小减小的最低时间阈值），高时间阈值<span class="math inline">\(F_{max}\)</span>/<span class="math inline">\(f_{min}\)</span>（用于引发驻留集大小增加的最高时间阈值）。<font color="red">注意这里的F表示时间，频率应取其倒数（<span class="math inline">\(f_{min} &lt; f_{max}\iff F_{max} &gt; F_{min}\)</span>）。</font> - <span class="math inline">\(f &lt; f_{min}\iff F &gt; F_{max}\)</span>：缺页率过低，驻留集可以适当减小。 - <span class="math inline">\(f &gt; f_{max}\iff F &lt; F_{min}\)</span>：缺页率过高，驻留集应当适当增大。 - <span class="math inline">\(f \in [f_{min},f_{max}]\iff F \in [F_{min},F_{max}]\)</span>：驻留集规模保持不变。</p>
<p>  主要的缺点： - 如果要转移到新的局部性阶段，则在过渡过程中其执行效果不太好</p>
<p><b><font color="purple">可变采样间隔的工作集（VSWS）策略</font></b> &gt;基本思想：<br>  在采样区间的开始处,该进程的所有驻留页的使用位被重置；在末尾处，只有在这个区间中被访问过的页才设置它们的使用位，这些也在下一个区间期间仍然保留在驻留集中，而其他页则被淘汰出驻留集。<br>  <font color="red">驻留集的大小只能在一个区间的末尾处减小，而在每个区间中，任何缺页中断都将导致该页被添加到驻留集中。</font></p>
<p>  工作过程： |parameters|meaning| |:-:|:-| M | 采样区间的最大宽度 L | 采样区间的最小宽度 Q | 采样实例间允许发生的缺页中断数量 - 若从上次采样示例至今的单位时间达到L，则挂起该进程并扫描使用位。 - 若在这个长度为L的虚拟时间区间内，发生了Q次缺页中断： - 若从上次采样示例至今的时间小于M，则等待，直到经过的虚拟时间到达M，才挂起该进程并扫描使用位。 - 若从上次采样实例至今的时间大于等于M，则挂起该进程并扫描使用位。</p>
<h2 id="加载控制">2.6、加载控制</h2>
<ul>
<li>系统并发度</li>
<li>进程挂起</li>
</ul>
<h1 id="unix和solaris内存管理">3、UNIX和Solaris内存管理</h1>
<h1 id="linux内存管理">4、Linux内存管理</h1>
<h1 id="windows内存管理">5、Windows内存管理</h1>
<h1 id="android内存管理">6、Android内存管理</h1>
<p><b></b></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url">2.计算机基础/c.操作系统/7.内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><font face="fangsong" size="4"> <font size="6">第七章-内存管理</font></font></p>
<h1 id="内存管理的需求">1、内存管理的需求</h1>
<ol type="1">
<li>重定位</li>
<li>保护</li>
<li>共享</li>
<li>逻辑组织</li>
<li>物理组织 ## 1.1、重定位   重定位就是程序的物理地址只有当运行时才是确定的，而地址可以是不同的。若程序不能够实现重定位，那么其每次装入内存的地址就必须是固定的，这会大大影响系统的效率。</li>
</ol>
<p>  处理器硬件和操作系统软件必须能以某种方式把程序代码中的内存访问转换为实际的物理内存地址，并反映程序在内存中的当前位置。</p>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/进程寻址需求.png%22"></p>
<h2 id="保护">1.2、保护</h2>
<p>  简而言之，保护是各个进程（用户进程、系统进程）不被其他进程有意无意的干扰。</p>
<p>  满足重定位增大了满足保护需求的难度：编译时无法通过检查绝对地址来确保保护。</p>
<p>  内存保护需求必须由<font color="red">处理器（硬件）</font>而非操作系统（软件）来满足，因为操作系统不能检测程序可能产生的所有内存。 ## 1.3、共享   共享是允许多个进程访问内存的同一部分。</p>
<p>  内存管理系统在不损害基本保护的前提下，必须对内存共享区域进行受控访问。 ## 1.4、逻辑组织   如果能将用户程序与数据组织成模块形式，且操作系统与硬件能够有效处理，则有以下好处： - 可以独立地编写和编译模块 - 通过适度的额外开销，可以为不同的模块提供不同的保护级别（只读、只执行等） - 可以引入某种机制使得模块可被多个进程共享。 - 在模块级提供共享符合用户看待问题的方式，因此用户可很容易的指定需要的共享。 ## 1.5、物理组织   在两极存储器间移动信息的任务应该由系统负责，这正是存储管理的本质。 &gt; 覆盖（overlaying）：不同的模块被分配到内存中的<font color="red">同一块区域</font>，主程序负责在需要时换入或换出模块。</p>
<h1 id="内存分区">2、内存分区</h1>
<h2 id="固定分区">2.1、固定分区</h2>
<h3 id="分区大小">2.1.1、分区大小</h3>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/固定分区.png%22"><br>固定分区大小</p>
<p>  相同大小固定分区的缺陷： - 程序太大——装不下 - 程序太小——内部碎片大，浪费空间</p>
<h3 id="放置算法">2.1.2、放置算法</h3>
<ul>
<li>大小相等的分区
<ul>
<li>随便放</li>
</ul></li>
<li>大小不等的分区
<ul>
<li>方案1：选择最优分区（能够容纳它的最小分区）
<ul>
<li><font color="red">每个分区要维护一个调度队列，该队列存储对应分区中换出的进程。</font></li>
<li>优点在于产生的内部碎片较少，缺点是资源消耗较高。</li>
</ul></li>
<li>方案2：性能与开销的折中——只有一条队列
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/不等长固定分区放置方法2.png%22"></li>
<li>当需要把一个进程装入内存时，选择可以容纳该进程的最小可用分区。</li>
<li>如果没有可用分区则需要进行交换，可以选择最小分区，也可选择阻塞进程所占用的分区。 ### 2.1.3、固定分区方案评价</li>
</ul></li>
</ul></li>
<li>优点
<ul>
<li>方案简单，开销较小</li>
</ul></li>
<li>缺点
<ul>
<li><font color="red">限制了系统中活动进程的数量</font></li>
<li>分区大小设置未必合理，故而可能比较低效 ## 2.2、动态分区 ### 2.2.1、基本原理与外部碎片   最开始时一点都不浪费空间，后来逐渐出现许多“细小空洞”，称为“外部碎片”，工作过程如下图所示： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/动态分区示例.png%22"></li>
</ul></li>
</ul>
<h3 id="内存压缩">2.2.2、内存压缩</h3>
<p>  用于解决外部碎片的问题。通过操作系统不时地移动进程，使得进程占用的空间连续，并使所有的空闲空间连成一片。 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/内存压缩.png%22"></p>
<p>  缺陷： - 内存压缩非常耗时且占用处理器时间 - 要求程序能够<font color="red">动态重定位</font> - 必须能够把程序从内存的一块区域移动到另一块区域，且不会使程序中的内存访问无效 - <font color="red">不同于前面所说的加载时重定位</font></p>
<h3 id="放置算法-1">2.2.3、放置算法</h3>
<ul>
<li>最佳适配（Best-fit）：选择与要求大小最接近的块。
<ul>
<li>通常性能最差,因为查找过程较慢且压缩次数更多（碎片太小）。</li>
</ul></li>
<li>首次适配（First-fit）：从头开始扫描内存，选择大小足够的第一个<font color="red">可用</font>块。
<ul>
<li>内存头部碎片会比较多。</li>
</ul></li>
<li>下次适配（Next-fit）：从上一次放置的位置开始扫描内存，选择下一个大小足够的可用块。
<ul>
<li><font color="red">为什么会有这种方案？原理是什么？因为碎片比较靠后？</font></li>
</ul></li>
</ul>
<h2 id="伙伴二叉兄弟节点系统">2.3、伙伴（二叉兄弟节点）系统</h2>
<p>  是固定分区与动态分区的折中（在克服了固定分区的进程数量限制以外，维护起来也比动态分区更简单）。</p>
<p><b>伪代码表述</b> - 可供分配的整个内存大小：<span class="math inline">\(2^U\)</span>字节 - 可能分配的最大块尺寸：<span class="math inline">\(2^U\)</span>字节 - 可能分配的最小块尺寸：<span class="math inline">\(2^L\)</span>字节 - 可用内存块大小：<span class="math inline">\(2^K \in [2^L,2^U]\)</span>，之所以 <span class="math inline">\(2^K \geqslant 2^L\)</span> 而不是 <span class="math inline">\(2^K \geqslant 0\)</span> ，是因为 <span class="math inline">\(2^L\)</span> 是不断二分得到的，不可能是0。</p>
<p>  该算法分配的块只能是2的整数次幂，首先要确定要申请空间 <span class="math inline">\(Size\)</span> 的范围区间 <span class="math inline">\([2^{i-1},2^i]\)</span>，然后通过下面递归算法找到一个大小为 <span class="math inline">\(2^i\)</span>大小的hole。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i_list(i=...) <span class="comment">// 系统维护的所有大小为2^i的hole的list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_hole</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==(U+<span class="number">1</span>))&#123;</span><br><span class="line">        &lt;failure&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i_list is empty)&#123;</span><br><span class="line">        get_gole(i+<span class="number">1</span>);</span><br><span class="line">        &lt;split hole into buddies&gt;;</span><br><span class="line">        &lt;<span class="built_in">put</span> buddies on i_list&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;take the first hole on i_list&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   另外，如果有两个“二叉节点”均未分配的话，二者应当合并为一个更大的块。</p>
<p><b>示例</b> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/伙伴系统算法示例.png%22"></p>
<p><b>二叉树表示</b> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/伙伴系统二叉树表示.png%22"></p>
<h2 id="重定位">2.4、重定位</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/重定位的硬件支持.png%22"><br>重定位的硬件支持</p>
<h1 id="分页">3、分页</h1>
<p>  从分页开始，逻辑地址出现，不过简单分页与简单分段中逻辑地址空间与物理地址空间是一致的。</p>
<p>  一个页表的例子如下图所示： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/页表示例.png%22"><br>页表示例   逻辑地址转换为物理地址过程如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/页表地址转换.png%22"><br>页表地址转换</p>
<h1 id="分段">4、分段</h1>
<p>  段表结构与页表相似。</p>
<p>  逻辑地址转换为物理地址过程如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/段表地址转换.png%22"><br>段表地址转换</p>
<h1 id="简单总结">5、简单总结</h1>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/简单总结.png%22"><br>简单总结</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">技术</th>
<th style="text-align: left;">说明</th>
<th style="text-align: left;">优势</th>
<th style="text-align: left;">弱势</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">固定分区</td>
<td style="text-align: left;">在系统生成阶段，内存被划分成许多静态分区。进程可装入大于等于自身大小的分区中。</td>
<td style="text-align: left;">实现简单，只需要极少的操作系统开销。</td>
<td style="text-align: left;">由于有内部碎片，对内存的使用不充分了活动进程的最大数量是固定的。</td>
</tr>
<tr class="even">
<td style="text-align: center;">动态分区</td>
<td style="text-align: left;">分区是动态创建的，因而每个进程可装入与自身大小正好相等的分区中。</td>
<td style="text-align: left;">没有内部碎片，可以更充分地使用内存。</td>
<td style="text-align: left;">由于需要压缩外部碎片，处理器利用率低。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">简单分页</td>
<td style="text-align: left;">内存被划分成许多大小相等的页框；每个进程被划分成许多大小与页框相等的页；要装入一个进程，需要把进程包含的所有页都装入内存内不一定连续的某些页框中。</td>
<td style="text-align: left;">没有外部碎片。</td>
<td style="text-align: left;">有少量的内部碎片。</td>
</tr>
<tr class="even">
<td style="text-align: center;">简单分段</td>
<td style="text-align: left;">内存被划分成许多段；要装入一个进程，需要把进程包含的所有段都装入内存内不一定连续的某些动态分区中。</td>
<td style="text-align: left;">没有内部碎片；相对于动态分区，提高了内存利用率，减少了开销。</td>
<td style="text-align: left;">存在外部碎片。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">虚存分页</td>
<td style="text-align: left;">除了<font color="red">不需要装入一个进程的所有页</font>外，与简单分页一样；非驻留页在以后需要时自动调入内存。</td>
<td style="text-align: left;">没有外部碎片；支持更多道数的多道程序设计；巨大的虚拟地址空间。</td>
<td style="text-align: left;">复杂的内存管理开销。</td>
</tr>
<tr class="even">
<td style="text-align: center;">虚存分段</td>
<td style="text-align: left;">除了<font color="red">不需要装入一个进程的所有段</font>外，与简单分段一样；非驻留段在以后需要时自动调入内存</td>
<td style="text-align: left;">没有内部碎片；支持更多道数的多道程序设计；巨大的虚拟地址空间；<font color="red">支持保护和共享</font>。</td>
<td style="text-align: left;">复杂的内存管理开销。</td>
</tr>
</tbody>
</table>
<h1 id="appendix加载和链接">Appendix、加载和链接</h1>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/" itemprop="url">2.计算机基础/c.操作系统/6.死锁与饥饿</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><font face="fangsong" size="4"></font></p>
<h1 id="死锁原理">1、死锁原理</h1>
<h2 id="资源">1.1、资源</h2>
<h3 id="可重用资源">1.1.1、可重用资源</h3>
<p>  指一次仅供一个进程安全使用且不因使用而耗尽的资源。例如：处理器、I/O设备、内存和外存、设备，以及诸如文件、数据库和信号量之类的数据结构。<br>   可重用资源死锁的例子： - 内存请求（可使用虚存解决） ### 1.1.2、可消耗资源   指可被创建和销毁的资源，例如send和receive中产生和销毁的message。 ### 1.1.3、资源分配图 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/资源分配图.png%22"><br>资源分配图示例</p>
<h2 id="联合进程图">1.2、联合进程图</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/联合进程图_死锁.png%22"><br>死锁示例</p>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/联合进程图_无死锁.png%22"><br>无死锁示例</p>
<h2 id="死锁产生的条件">1.3、死锁产生的条件</h2>
<p>  四个条件： - 互斥：一次只有一个进程可以使用一个资源，其他进程不能访问已分配给其他进程的资源。 - 占有且等待：当一个进程等待其他进程时，继续占有已分配的资源。 - 不可抢占：不能强行抢占进程已占有的资源。 - 循环等待：存在一个闭合的进程链，每个进程至少占由此链中下一个进程所需的一个资源。</p>
<p><span class="math display">\[\text{死锁}\Rightarrow \text{\{互斥、占有且等待、不可抢占\}}\]</span> <span class="math display">\[\text{\{互斥、占有且等待、不可抢占、\red{循环等待}\}}\Leftrightarrow \text{死锁}\]</span></p>
<h1 id="死锁解决策略">2、死锁解决策略</h1>
<p>  整体上来说，死锁解决策略有如下三种 - 死锁预防：试图设计一种系统来排除发生死锁的可能性。 - 约束资源请求至少可破坏四个死锁条件中的一个条件。 - 会导致低效的资源使用和低效的进程执行。 - 死锁避免：与死锁预防差别很小，一定程度上可看做是死锁预防的特例。 - 允许三个必要条件，但通过明智的选择使得第四个条件不成立。 - <font color="red">死锁避免比死锁预防允许更多的并发</font>。 - 死锁检测：比死锁避免更开放，核心思想是“错误-&gt;回滚-&gt; <span class="math inline">\(\cdots\)</span> -&gt;正确”。 - 不限制资源访问或约束进程行为，只要有可能，就会给进程分配其所请求的资源。 - 频繁的检测需要消耗相当多的处理器时间。 - 检测到死锁后需要某种策略来恢复死锁前的状态。</p>
<h2 id="死锁预防">2.1、死锁预防</h2>
<p>  从四个条件入手： - 互斥 - 一般不能禁止 - 占有且等待 - 修改方案：可以要求进程一次性的请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。 - 不可抢占（资源状态可以很容易地保存和恢复时该方案才实用） - 修改方案1：申请资源时如果被拒绝则要释放已占有的资源 - 修改方案2：一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源（需要两个进程的优先级不同，否则还是会死锁）。 - 循环等待 - 修改方案：定义资源类型的线性顺序：若一个进程已分配了R类型的资源，则其接下来请求的资源只能是那些排在R类型之后的资源（可通过反证法证明其正确性）。</p>
<h2 id="死锁避免">2.2、死锁避免</h2>
<p>  优点： - 无须死锁检测中的抢占和回滚进程，且与死锁预防相比限制较少。</p>
<p>  限制： - 必须事先声明每个进程请求的最大资源 - 所讨论的进程必须是无关的，即他们的执行顺序必须没有任何同步要求的限制 - 分配的资源数量必须是固定的 - 在占有资源时，进程不能退出 ### 2.2.1、进程启动拒绝 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/进程启动拒绝向量矩阵.png%22"><br>进程启动拒绝的相关数据</p>
<p>  进程启动条件：<span class="math inline">\(R_j \geqslant C_{(n+1)j} + \sum\limits_{i=1}^{n}C_{ij}\)</span>（已经启动的进程对资源R的最大需求 + 将要启动的进程对资源R的最大需求 <span class="math inline">\(\leqslant\)</span> 资源R的总数量）。</p>
<p>  简而言之，<font color="red">时刻保持<span class="math inline">\(R\)</span>能够满足所有已经启动进程的最大资源需求</font>。</p>
<h3 id="资源分配拒绝">2.2.2、资源分配拒绝</h3>
<ul>
<li>安全状态：至少有一个资源分配序列不会导致死锁。
<ul>
<li>安全序列：安全序列是指一个进程序列{P1，…，Pn}是安全的，即对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj(j&lt;i)当前占有资源量之和。</li>
</ul></li>
<li>不安全状态：就是不安全的状态……
<ul>
<li>不安全状态并非一定是死锁状态，如果一个进程申请的资源当前是可用的，但该进程必须等待，这样资源利用率会下降。</li>
</ul></li>
</ul>
<p>  核心：进程请求一组资源时，假设同意该请求，然后确定结果是否仍然处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程直到同意该请求后系统状态仍然是安全的。<br>   记录要请求的资源向量为<span class="math inline">\(V_{req}\)</span>，然后记录临时向量<span class="math inline">\(W=V-V_{req}\)</span>，然后对向量<span class="math inline">\(W\)</span>和矩阵<span class="math inline">\(Q\)</span>进行检测来决定要不要允许资源分配。如果<span class="math inline">\(\exists\ i\)</span>使得向量<span class="math inline">\(Q[i]\)</span>中的每一项都小于向量<span class="math inline">\(W[j]\)</span>，那么就允许该资源的分配。</p>
<p>  资源分配拒绝的核心在于，<font color="red">时刻保证资源<span class="math inline">\(R\)</span>能够使得系统处于安全状态</font>。</p>
<p>  代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*全局数据结构*/</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> resource[m];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">available</span>[m];</span><br><span class="line">    <span class="keyword">int</span> claim[n][m];</span><br><span class="line">    <span class="keyword">int</span> alloc[n][m];</span><br><span class="line">&#125;state,newstate;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*测试安全算法（银行家算法）*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">safe</span><span class="params">(State S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentavail[m];</span><br><span class="line">    <span class="built_in">process</span> rest[&lt;number of processes&gt;];</span><br><span class="line">    currentavail[*] = <span class="built_in">available</span>[*];</span><br><span class="line">    rest = &#123;all processes&#125;;</span><br><span class="line">    possible = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(possible)&#123;</span><br><span class="line">        <span class="comment">// 如果有，那么谁前谁后应没有太大区别</span></span><br><span class="line">        &lt;<span class="built_in">find</span> a <span class="built_in">process</span> Pk in rest such that</span><br><span class="line">        claim[k,*] - alloc[k,*] &lt;= currentavail[*]&gt;;</span><br><span class="line">        <span class="keyword">if</span>(found)&#123;</span><br><span class="line">            currentavail[*] = currentavail[*] + alloc[k,*]; <span class="comment">// vector add</span></span><br><span class="line">            rest = rest - &#123;Pk&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            possible = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rest==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*资源分配算法*/</span> </span><br><span class="line"><span class="keyword">if</span>(alloc[i,*]+request[*] &gt; claim[i,*])&#123;</span><br><span class="line">    &lt;error&gt;</span><br><span class="line">    <span class="comment">// 确认进程i的资源请求符合其声明的最大需求</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(request[*] &gt; <span class="built_in">available</span>[*])&#123;</span><br><span class="line">    &lt;suspend <span class="built_in">process</span>&gt;</span><br><span class="line">    <span class="comment">// （允许后必然死锁）阻塞/挂起进程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    define newstate by:&#123;</span><br><span class="line">        alloc[i,*] = alloc[i,*] + request[*];</span><br><span class="line">        <span class="built_in">available</span>[*] = <span class="built_in">available</span>[*] - request[*];</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="comment">// （允许后可能死锁）记录新的状态newstate，用于后面测试安全性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设已经同意该请求，然后看看会不会死锁（所有进程整体，包括之后的请求分配等）</span></span><br><span class="line"><span class="keyword">if</span>(safe(newstate))&#123;</span><br><span class="line">    &lt;carry out allocation&gt;</span><br><span class="line">    <span class="comment">// 不会死锁，进程执行，state更新（state = newstate）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    &lt;restore original state&gt;;</span><br><span class="line">    &lt;suspend <span class="built_in">process</span>&gt;;</span><br><span class="line">    <span class="comment">// 会死锁，进程挂起，state不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  通过题目进行理解： - <a href="https://blog.csdn.net/muxuanyan/article/details/46820727" target="_blank" rel="noopener">例题1</a><br> - <a href="https://wenku.baidu.com/view/c0a2ca0cb8f67c1cfbd6b82b.html" target="_blank" rel="noopener">例题2</a></p>
<h2 id="死锁检测">2.3、死锁检测</h2>
<h3 id="死锁检测算法">2.3.1、死锁检测算法</h3>
<p>  死锁检测算法相比于死锁避免，其条件进一步放宽。相比于死锁避免中资源分配拒绝方法时刻需要保证至少有一个安全序列，死锁检测只需要时刻保证资源<span class="math inline">\(R\)</span>至少能够使得一个进程执行结束，然后每隔一段时间进行检测，看能否通过不断回收资源使得所有进程都能执行完成。<br>   简而言之，<font color="red">资源分配拒绝允许分配资源的前提是分配后系统存在一个所有进程的安全序列，而死锁检测则是分配资源后向量<span class="math inline">\(R\)</span>至少能够使得一个进程顺利执行完成</font>。</p>
<p>  算法过程： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/死锁检测过程.png%22"></p>
<p>  例子： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/死锁检测示例.png%22"></p>
<h3 id="恢复回滚">2.3.2、恢复/回滚</h3>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF/恢复and回滚.png%22"></p>
<h2 id="一种综合的死锁策略">2.4、一种综合的死锁策略</h2>
<p>  解决死锁的所有策略都各有优缺点，与其将操作系统机制设计为只采用其中的一种策略，不如在不同情况下使用不同的策略。</p>
<p>  一种综合的方案是把资源分成几组不同的资源类： - 资源类之间采用线性排序策略（死锁预防）避免发生资源类之间循环等待的死锁。 - 资源类之内根据情况采用不同的算法来避免发生资源类之内循环等待的死锁。</p>
<p>  举例： - 可交换空间：进程交换所用外存中的存储块 - 方案：可要求一次性分配所有请求的资源来预防死锁 - 进程资源：可分配的设备，如磁带设备和文件 - 方案1：死锁避免策略 - 方案2：采用资源排序的死锁预防策略 - 内存：可按页或按段分配给进程 - 方案：基于抢占的预防 - 内部资源：诸如I/O通道 - 方案：基于资源排序的预防</p>
<h1 id="哲学家就餐问题">3、哲学家就餐问题</h1>
<h2 id="基于信号量的解决方案">3.1、基于信号量的解决方案</h2>
<p>  通过增加一个“服务员”来保证每次只会有四个“哲学家”进入餐厅就餐。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* dinning philosophers*/</span></span><br><span class="line">semaphore forks[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">semaphore room = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        think();</span><br><span class="line">        wait(room);</span><br><span class="line">        wait(fork[i]);</span><br><span class="line">        wait(fork[i+<span class="number">1</span>]%<span class="number">5</span>);</span><br><span class="line">        eat();</span><br><span class="line">        signal(fork[i+<span class="number">1</span>]%<span class="number">5</span>);</span><br><span class="line">        signal(fork[i]);</span><br><span class="line">        signal(room);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin(philosopher(<span class="number">0</span>),philosopher(<span class="number">1</span>),philosopher(<span class="number">2</span>),\</span><br><span class="line">             philosopher(<span class="number">3</span>),philosopher(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 3.2、基于管程的解决方案   管程的解决方案保证了<font color="red">同一时刻只有一位哲学家进入餐厅</font>（不存在五位哲学家同时进入餐厅然后同时拿起左边的叉子的情况），第一位进入餐厅的哲学家必然是能够拿到两把叉子的。<br>   管程设计如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">monitor dinning_controler;</span><br><span class="line">cond ForkReady[<span class="number">5</span>];          <span class="comment">/* condition variables for synchronization */</span></span><br><span class="line"><span class="keyword">bool</span> fork[<span class="number">5</span>] = &#123;<span class="literal">true</span>&#125;;      <span class="comment">/* avalible status of each fork */</span></span><br><span class="line"><span class="comment">// 取叉子管程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_forks</span><span class="params">(<span class="keyword">int</span> pid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = pid;</span><br><span class="line">    <span class="keyword">int</span> right = (pid+<span class="number">1</span>)%<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(fork[left]==<span class="literal">false</span>)&#123;</span><br><span class="line">        cwait(ForkReady[left]);</span><br><span class="line">        <span class="comment">/* wait on condition variable ForkReady[left] */</span></span><br><span class="line">    &#125;        </span><br><span class="line">    fork[left]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(fork[right]==<span class="literal">false</span>)&#123;</span><br><span class="line">        cwait(ForkReady[right]);</span><br><span class="line">        <span class="comment">/* wait on condition variable ForkReady[right] */</span></span><br><span class="line">    &#125;</span><br><span class="line">    fork[right]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 放叉子管程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_forks</span><span class="params">(<span class="keyword">int</span> pid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = pid;</span><br><span class="line">    <span class="keyword">int</span> right = (pid+<span class="number">1</span>)%<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(ForkReady[left]))&#123;</span><br><span class="line">        <span class="comment">/* no one is waiting for this fork */</span></span><br><span class="line">        fork[left]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* at least one philosopher is waiting for this fork */</span></span><br><span class="line">        csignal(ForkReady[left]);</span><br><span class="line">        <span class="comment">/* awake a process waiting on this fork */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(ForkReady[right]))&#123;</span><br><span class="line">        fork[right]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        csignal(ForkReady[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   调用管程代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> pid)</span></span>&#123;</span><br><span class="line">    think();</span><br><span class="line">    get_forks(pid);</span><br><span class="line">    eat();</span><br><span class="line">    realese_forks(pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin(philosopher(<span class="number">0</span>),philosopher(<span class="number">1</span>),philosopher(<span class="number">2</span>),\</span><br><span class="line">             philosopher(<span class="number">3</span>),philosopher(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 4、UNIX并发机制 # 5、Linux内核并发机制 # 6、Solaris线程同步原语 # 7、Windows7的并发机制 # 8、Android进程间通信</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/" itemprop="url">2.计算机基础/c.操作系统/5.互斥与同步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&lt;font face="fangsong") <font size="6"><b>C5并发性：互斥与同步</b></font> <font size="4"></font></p>
<h1 id="总览">0、总览</h1>
<ul>
<li>三个问题：{简单互斥、生产者/消费者问题，读者/写者问题}</li>
<li>五种机制：{中断，互斥量与原子指令，信号量与PV原语，管程，消息传递与send/receive原语}
<ul>
<li>最基础：中断，互斥量与原子指令</li>
<li>高一层：信号量与PV原语（原语由上一层实现）</li>
<li>“面向对象”的管程：实现涉及到上面两层</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">相关术语</th>
<th style="text-align: left;">含义解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">原子操作</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">临界区</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">死锁</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">活锁</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">互斥</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">竞争条件</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">饥饿</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h1 id="互斥的硬件支持">1、互斥的硬件支持</h1>
<ul>
<li>中断禁用（适合单处理器的机器）</li>
<li>专用机器指令
<ul>
<li>compare&amp;swap指令</li>
<li>exchange指令</li>
<li><font color="red">二者的区别在于提供了一个指针参数还是两个立即数参数</font> ## 1.1、通过中断提供互斥   通过禁用中断从而使得进程之间不再通过时钟分片进行轮转。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    &#x2F;* 禁用中断 *&#x2F;</span><br><span class="line">    &#x2F;* 临界区，该段代码将会一直执行到启用中断 *&#x2F;</span><br><span class="line">    &#x2F;* 启用中断 *&#x2F;</span><br><span class="line">    &#x2F;* 其余部分 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 1.2、比较和交换指令   该原子操作指令的逻辑如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_swap</span><span class="params">(<span class="keyword">int</span> *ptr_oldval, <span class="keyword">int</span> testval, <span class="keyword">int</span> newval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldval = *ptr_oldval; </span><br><span class="line">    <span class="keyword">if</span>(oldval == testval)</span><br><span class="line">        *ptr_oldval = newval;</span><br><span class="line">    <span class="keyword">return</span> oldval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   使用该指令实现互斥的代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mutex; <span class="comment">/* 0:can execute the critical codes, 1:can't ... */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> pid)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">while</span>(compare_swap(&amp;mutex,<span class="number">1</span>,<span class="number">0</span>)==<span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">    <span class="comment">/* critical code */</span></span><br><span class="line">    mutex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* other codes */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mutex = <span class="number">0</span>;</span><br><span class="line">    parbegin(P(<span class="number">1</span>),P(<span class="number">2</span>),...,P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 1.3、寄存器/内存交换指令   该原子操作指令的逻辑如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">register</span>,<span class="keyword">int</span> *memory)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *<span class="keyword">register</span>;</span><br><span class="line">    *<span class="keyword">register</span> = *memory;</span><br><span class="line">    *memory = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   使用该指令实现互斥的代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> pid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> occupied = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(occupied == <span class="literal">true</span>)</span><br><span class="line">            exchange(&amp;occupied,&amp;mutex);</span><br><span class="line">        <span class="comment">/* critical codes */</span></span><br><span class="line">        mutex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* other codes */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mutex = <span class="number">0</span>;</span><br><span class="line">    parbegin(P(<span class="number">1</span>),P(<span class="number">2</span>),...,P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 2、信号量</li>
</ul></li>
<li>注意：
<ul>
<li>1、当进程执行semWait之后该进程要么进入信号量的排队队列，要么进入就绪队列，对于阻塞的进程，此后都将由信号量对其进行调度。</li>
<li>2、强信号量：FIFO（可以保证不会饥饿，弱信号量则不行）；弱信号量：没有规定进程从队列中移出顺序的信号量</li>
<li>3、信号量的semWait和semSignal是原子操作 ## 2.1、信号量原语（原子操作） ### 2.1.1、二元信号量 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元信号量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;zero, one&#125; value;</span><br><span class="line">    queueType <span class="built_in">queue</span>; <span class="comment">// 进程排队</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(binary_semaphore s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 等价于一般信号量中的s.count--;</span></span><br><span class="line">    <span class="keyword">if</span>(s.value==one)&#123;</span><br><span class="line">        s.value = zero;</span><br><span class="line">        <span class="comment">// 此时有资源供当前进程使用，不需要排队</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把当前进程插入到队列当中（排队等待）</span></span><br><span class="line"><span class="comment">        阻塞当前进程</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> semSignal(binary_semaphore s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty)&#123;</span><br><span class="line">        s.value = one;</span><br><span class="line">        <span class="comment">// 所有排队进程都已经执行完以后才会释放资源</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把某一进程P从队列中移除（某一个排队的可以不排了）</span></span><br><span class="line"><span class="comment">        把进程P插入到就绪队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   与二元信号量相关的一个概念是互斥量。两者的关健区别在于为互斥量加锁(设定其值为0)的进程和为互斥量解锁(设定其值为1)的进程必须是同一个进程。相比之下,可能由某个进程对二元信号量进行加锁操作,而由另一个进程为其解锁。 ### 2.1.2、一般信号量（计数信号量） <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般信号量（计数信号量）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// Qestion: count的初始值应该是多少？？</span></span><br><span class="line">    queueType <span class="built_in">queue</span>; <span class="comment">// 进程排队</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把当前进程插入到队列s.queue当中（排队等待）</span></span><br><span class="line"><span class="comment">        阻塞当前进程</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果s.count--之后仍然≥0，则说明有资源供当前进程使用，不需要排队</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把某一进程P从队列中移除（某一个排队的可以不排了）</span></span><br><span class="line"><span class="comment">        把进程P插入到就绪队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果s.count++之后&gt;0，则说明没有进程在排队，所以不需要激活进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 2.2、使用信号量的互斥 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*program mutual_exclusion*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程数*/</span></span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    semWait(s);</span><br><span class="line">    <span class="comment">/* critical codes */</span></span><br><span class="line">    semSignal(s);</span><br><span class="line">    <span class="comment">/* other codes */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin(P(<span class="number">1</span>),P(<span class="number">2</span>),...,P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 2.3、（一般）信号量的实现方式 ### 2.3.1、通过中断方式实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a、中断方式（可以在单处理器系统上使用）</span></span><br><span class="line">semWait(semaphore s)&#123;</span><br><span class="line">    <span class="keyword">asm</span> cli </span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把当前进程插入到队列s.queue当中（排队等待）</span></span><br><span class="line"><span class="comment">        阻塞当前进程</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">asm</span> sti</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">asm</span> sti</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(semaphore s)&#123;</span><br><span class="line">    <span class="keyword">asm</span> cli</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把某一进程P从队列中移除（某一个排队的可以不排了）</span></span><br><span class="line"><span class="comment">        把进程P插入到就绪队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">asm</span> sti </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 2.3.2、通过特殊硬件指令实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b、比较并交换指令</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">word</span>,<span class="keyword">int</span> testval,<span class="keyword">int</span> newval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldval = *<span class="keyword">word</span>;</span><br><span class="line">    <span class="keyword">if</span>(oldval == testval)&#123;</span><br><span class="line">        *<span class="keyword">word</span> = newval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semWait(semaphore s)&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag,<span class="number">0</span>,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把当前进程插入到队列s.queue当中（排队等待）</span></span><br><span class="line"><span class="comment">        阻塞当前进程</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        s.flag = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s.flag = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(semaphore s)&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag,<span class="number">0</span>,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把某一进程P从队列中移除（某一个排队的可以不排了）</span></span><br><span class="line"><span class="comment">        把进程P插入到就绪队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s.flag = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h1 id="管程">3、管程</h1>
<h2 id="是什么与为什么">3.1、是什么与为什么</h2>
<h3 id="什么是管程">3.1.1、什么是管程？</h3>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/管程结构.png%22"></p>
<p>  管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现进程级别的并发控制。管程中的数据变量每次只能被一个进程访问。   管程自身带有互斥的属性，可以这样认为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entrance of the monitor:</span><br><span class="line">    &#x2F;* 互斥进入管程 *&#x2F;</span><br><span class="line">    &#x2F;* 管程实体，这里面可能有其余互斥量&#x2F;信号量等 *&#x2F;</span><br><span class="line">    &#x2F;* 退出管程，发出相应信号 *&#x2F;</span><br></pre></td></tr></table></figure>   管程是在互斥量与信号量的基础上进一步抽象的高层设计，这种设计简化了程序员编写代码的过程，不过<font color="red">在编写代码前，需要先设计好管程</font>。</p>
<p>  管程的特征 - 模块化：管程是一个基本的软件模块，可以被单独编译。 - 抽象数据类型：管程中封装了数据及对于数据的操作，这点有点像面向对象编程语言中的类。 - 信息隐藏：管程外的进程或其他软件模块只能通过管程对外的接口来访问管程提供的操作，管程内部的实现细节对外界是透明的。 - 使用的互斥性：任何一个时刻，管程只能由一个进程使用。进入管程时的互斥由编译器负责完成。</p>
<h3 id="信号量vs管程">3.1.2、信号量vs管程</h3>
<p>  使用信号量设计一个正确的程序是很困难的，难点在于semWait和semSignal操作可能分布在整个程序中，而很难看出信号量上的这些操作所产生的整体效果。而管程则将所有的同步机制限制在管程内部，因此不但易于验证同步的正确性，而且易于检测出错误。</p>
<h2 id="使用管程实现的互斥">3.2、使用管程实现的互斥</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(pid)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* not critical codes */</span></span><br><span class="line">    in critical codes part:</span><br><span class="line">        &lt;invoke the functions defined in the monitor&gt;</span><br><span class="line">    <span class="comment">/* not critical codes */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin(P(<span class="number">1</span>),P(<span class="number">2</span>),...,P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用通知和广播的管程">3.3、使用通知和广播的管程</h2>
<p>  使用循环的<code>cwait</code>以及有别于<code>csignal</code>的<code>cnotify</code>、<code>cbroadcast</code>。该方法错误更少，并且有助于在程序结构中采用更加模块化的方法。</p>
<h1 id="消息传递">4、消息传递</h1>
<h2 id="概述">4.1、概述</h2>
<p>  两种原语： - send(destination,message) - receive(source,message)</p>
<p>  三种组合 - 阻塞send，阻塞receive - 无阻塞send，阻塞receive - 无阻塞send，无阻塞receive</p>
<p>  两种寻址 - 直接寻址 - 间接寻址 ## 4.2、寻址 ### 4.2.1、直接寻址 - send原语：send原语包含目标进程的标识号。 - receive原语 - 方式一：显示指定源进程，所以进程必须事先知道希望得到来自哪个进程的消息。 - 方式二：不指定所期望的源进程，例如打印机的服务器进程。对这种应用使用隐式寻址更为有效。</p>
<p>  结构图如下： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/直接寻址.png%22"></p>
<h3 id="间接寻址">4.2.2、间接寻址</h3>
<p>  主要有下面四种结构： - 一对一： - 允许在两个进程间建立专用的通信链接，隔离它们的交互，避免其他进程的错误干扰。 - 是典型的<font color="red">静态和永久性关系</font>。 - 多对一 - 一个进程给许多其他进程提供服务 - 对客户-服务器间的交互非常有用 - 这时信箱常称为一个<font color="red">端口</font> - 一对多 - 广播 - 多对多 - 可以让多个服务进程对多个客户进程提供服务（例如集群？）</p>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/间接寻址.png%22"></p>
<p>  相关问题： - 信箱与进程动态关联 or 静态关联？ - 信箱所有权问题。</p>
<h2 id="消息格式">4.3、消息格式</h2>
<p>  因果如下所示：<br> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/消息格式因果关系.png%22"></p>
<p>  变长消息的典型格式如下：<br> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/变长消息格式.png%22"></p>
<h2 id="排队原则">4.4、排队原则</h2>
<ul>
<li>FIFO</li>
<li>带有优先级的排队规则</li>
</ul>
<h2 id="使用消息传递的互斥">4.5、使用消息传递的互斥</h2>
<p>  相当于在<font color="red">传递一个令牌</font>，谁拥有令牌谁有有资格进入临界区。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程数*/</span></span><br><span class="line"><span class="keyword">void</span> P(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        receive(box,msg); <span class="comment">// 原子操作，信箱为空时将阻塞该进程</span></span><br><span class="line">        <span class="comment">/* critical codes */</span></span><br><span class="line">        send(box,msg); <span class="comment">// 原子操作</span></span><br><span class="line">        <span class="comment">/* the rest codes */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    create_mailbox(box);</span><br><span class="line">    send(box,null); <span class="comment">// 创建一个令牌，可以激活一个进程</span></span><br><span class="line">    parbegin(P(i),P(<span class="number">2</span>),...,P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="生产者消费者问题使用信号量">5、生产者消费者问题（使用信号量）</h1>
<h2 id="使用信号量解决生产者消费者问题">5.1、使用信号量解决生产者/消费者问题</h2>
<h3 id="使用二元信号量解决无限缓冲区生产者消费者问题的方法">5.1.1、使用二元信号量解决无限缓冲区生产者/消费者问题的方法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用二元信号量解决无限缓冲区生产者/消费者问题的方法</span></span><br><span class="line"><span class="comment">/* program producer_consumer */</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>; <span class="comment">// 已生产的数据数量</span></span><br><span class="line">binary_semaphore s=<span class="number">1</span>, <span class="built_in">delay</span>=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(s);</span><br><span class="line">            append();</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">                semSignal(<span class="built_in">delay</span>);</span><br><span class="line">                <span class="comment">// 已经有数据了，consumer可以执行了</span></span><br><span class="line">            &#125;</span><br><span class="line">        semSignal(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    semWait(<span class="built_in">delay</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        semWait(s);</span><br><span class="line">            take();</span><br><span class="line">            n--;</span><br><span class="line">            m = n; <span class="comment">// 注意m的使用</span></span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            semWait(<span class="built_in">delay</span>);</span><br><span class="line">            <span class="comment">// 当前没有未消费的数据，consumer阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin(producer,consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用一般信号量解决无限缓冲区生产者消费者问题的方法">5.1.2、使用一般信号量解决无限缓冲区生产者/消费者问题的方法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一般信号量解决无限缓冲区生产者/消费者问题的方法</span></span><br><span class="line"><span class="comment">/* program producer_consumer */</span></span><br><span class="line">semaphore n=<span class="number">0</span>;</span><br><span class="line">semaphore s=<span class="number">1</span>; <span class="comment">// 最多只能同时有一个信号量s上的进程运行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(s);</span><br><span class="line">            append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        semWait(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">            take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin(producer,consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用一般信号量解决有限缓冲区生产者消费者问题的方法">5.1.3、使用一般信号量解决有限缓冲区生产者/消费者问题的方法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一般信号量解决有限缓冲区生产者/消费者问题的方法</span></span><br><span class="line"><span class="comment">/* program producer_consumer */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size_of_buffer = <span class="comment">/*缓冲区大小*/</span></span><br><span class="line">semaphore n = <span class="number">0</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>; <span class="comment">// 最多只能同时有一个信号量s上的进程运行</span></span><br><span class="line">semaphore e = size_of_buffer;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(e); <span class="comment">// 生产者数量有限，可能需要排队</span></span><br><span class="line">        semWait(s);</span><br><span class="line">            append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        semWait(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">            take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(e);</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin(producer,consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用管程解决生产者消费者问题">5.2、使用管程解决生产者/消费者问题</h2>
<h3 id="管程设计">5.2.1、管程设计</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这一整个过程中每次只允许一个进程进入 */</span></span><br><span class="line">monitor boundedbuffer;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[N];</span><br><span class="line"><span class="keyword">int</span> nextin,nextout;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">cond notfull,notempty;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count==N)&#123;</span><br><span class="line">        cwait(notfull);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">buffer</span>[nextin] = x;</span><br><span class="line">    nextin=(nextin+<span class="number">1</span>)%N;</span><br><span class="line">    count++;</span><br><span class="line">    csignal(notempty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        cwait(notempty);</span><br><span class="line">    &#125;</span><br><span class="line">    x = <span class="built_in">buffer</span>[nextout];</span><br><span class="line">    nextout=(nextout+<span class="number">1</span>)%N;</span><br><span class="line">    count--;</span><br><span class="line">    csignal(notfull);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    nextin = <span class="number">0</span></span><br><span class="line">    nextout = <span class="number">0</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用管程解决生产者消费者问题">5.2.2、调用管程解决生产者/消费者问题</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 由于使用了管程，所以不需要额外使用互斥锁等机制 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        produce(x);</span><br><span class="line">        append(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        take(x);</span><br><span class="line">        consume(X);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin(producer(),consumer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用消息传递解决有界缓冲区生产者消费者问题的一种方法">5.3、使用消息传递解决有界缓冲区生产者/消费者问题的一种方法</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> capacity = <span class="comment">/* 缓冲区容量 */</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> null = <span class="comment">/* 空消息 */</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">mailbox mayproduce,mayconsume;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    message pmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        receive(mayproduce,pmsg); <span class="comment">// 应当看做是引用传递</span></span><br><span class="line">        pmsg = produce();</span><br><span class="line">        send(mayconsume,pmsg);</span><br><span class="line">        <span class="comment">// 取得pmsg进行修改然后发给mayconsume</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    message cmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        receive(mayconsumer,cmsg);</span><br><span class="line">        consume(cmsg);</span><br><span class="line">        send(mayproduce,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    create_mailbox(mayproduce);</span><br><span class="line">    create_mailbox(mayconsume);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> it=<span class="number">0</span>;it&lt;capacity;++it)&#123;</span><br><span class="line">        send(mayproduce,null);</span><br><span class="line">        <span class="comment">// 产生capacity个空位</span></span><br><span class="line">    &#125;</span><br><span class="line">    parbegiin(producer,consumer); <span class="comment">// 只有一个消费者和一个生产者的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  消息传递方案的优势： - 方法灵活，可以有多个消费者和多个生产者（只要它们都访问同一个mayproduce和mayconsume信箱）。 - 系统甚至可以是分布式系统（不过需要所有生产者进程和mayproduce信箱在一个站点上，所有消费者进程和mayconsume信箱也在同一个站点上）。这里是说前面的几种都是在同一台机器上的，消息传递突破了这个限制。</p>
<h1 id="读者写者问题">6、读者/写者问题</h1>
<h2 id="使用信号量解决">6.1、使用信号量解决</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">进程状态</th>
<th style="text-align: left;">队列情况</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
| 系统中只有读进程 |
<ul>
<li>
设置wsem
</li>
<li>
无队列
</li>
</ul>
| | 系统中只有写进程 |
<ul>
<li>
设置wsem和rsem
</li>
<li>
写进程在wsem上排队
</li>
</ul>
| | 系统中既有读进程又有写进程，<br>但读进程优先|
<ul>
<li>
<font color="red">由读进程设置wsem</font>
</li>
<li>
由写进程设置rsem
</li>
<li>
所有写进程在wsem上排队
</li>
<li>
一个读进程在rsem上排队
</li>
<li>
其他读进程在z上排队
</li>
</ul>
| | 系统中既有读进程又有写进程，<br>但写进程优先|
<ul>
<li>
<font color="red">由写进程设置wsem</font>
</li>
<li>
由写进程设置rsem
</li>
<li>
所有写进程在wsem上排队
</li>
<li>
一个读进程在rsem上排队
</li>
<li>
其他读进程在z上排队
</li>
</ul>
<p>| ### 6.1.1、读者优先 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Program readers_and_writers*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Semphore;</span><br><span class="line"><span class="keyword">int</span> readcount; <span class="comment">// readcount用于记录当前正在进行的读操作</span></span><br><span class="line">Semphore x=<span class="number">1</span>; <span class="comment">// x是用于保证修改readcount时互斥的信号量</span></span><br><span class="line">Semphore wsem=<span class="number">1</span>; <span class="comment">// wsem是用于保证读写操作（读-写，写-写）互斥的信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 互斥进行readcount的修改</span></span><br><span class="line">        semWait(x);</span><br><span class="line">            readcount++;</span><br><span class="line">            <span class="keyword">if</span>(readcoount==<span class="number">1</span>)&#123;</span><br><span class="line">                semWait(wsem);</span><br><span class="line">                <span class="comment">// 如果当前没有读进程，那就要确保没有写进程才可执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        semSignal(x);</span><br><span class="line">        <span class="comment">// 进行读取操作，读操作不需要互斥</span></span><br><span class="line">        READUNIT();</span><br><span class="line">        <span class="comment">// 互斥进行readcount的修改      </span></span><br><span class="line">        semWait(x);</span><br><span class="line">            readcount--;</span><br><span class="line">            <span class="keyword">if</span>(readcount==<span class="number">0</span>)&#123;</span><br><span class="line">                semSignal(wsem);</span><br><span class="line">            &#125;</span><br><span class="line">        semSignal(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        semWait(wsem);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    readcount = <span class="number">0</span>;</span><br><span class="line">    parbegin(reader,writer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 6.1.2、写者优先 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*program readers_and_writers*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Semphore;</span><br><span class="line"><span class="keyword">int</span> readcount; <span class="comment">// readcount用于记录当前正在进行的读操作数量</span></span><br><span class="line"><span class="keyword">int</span> writecount; <span class="comment">// writecount用于记录当前正在进行的写操作数量</span></span><br><span class="line">Semphore x=<span class="number">1</span>; <span class="comment">// x是用于保证修改readcount时互斥的信号量</span></span><br><span class="line">Semphore y=<span class="number">1</span>; <span class="comment">// y是用于保证修改writecount时互斥的信号量</span></span><br><span class="line">Semphore z=<span class="number">1</span>; <span class="comment">// z是用于保证修改writecount时互斥的信号量</span></span><br><span class="line">Semphore rsem=<span class="number">1</span>; <span class="comment">// rsem是用于保证读写操作（读-写，写-写）互斥的信号量</span></span><br><span class="line">Semphore wsem=<span class="number">1</span>; <span class="comment">// wsem是用于保证读写操作（读-写，写-写）互斥的信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 未进入的</span></span><br><span class="line">        senWait(z); <span class="comment">// 是优化，并非必须</span></span><br><span class="line">            <span class="comment">// 如果所有读进程都在rsem上排队，则导致队伍很长，写进程排很久才轮到</span></span><br><span class="line">            <span class="comment">// 通过z和rsem双重排队，导致同一时刻最多有1个读进程在rsem上排队</span></span><br><span class="line">            semWait(rsem);</span><br><span class="line">                semWait(x);</span><br><span class="line">                    readcount++;</span><br><span class="line">                    <span class="keyword">if</span>(readcount==<span class="number">1</span>)&#123;</span><br><span class="line">                        semWait(wsem);</span><br><span class="line">                    &#125;</span><br><span class="line">                semSignal(x);</span><br><span class="line">            semSignal(rsem);</span><br><span class="line">        semSignal(z); <span class="comment">// 是优化，并非必须</span></span><br><span class="line">        <span class="comment">// 进行读取操作，读操作不需要互斥</span></span><br><span class="line">        READUNIT();</span><br><span class="line">        <span class="comment">// 读操作退出过程互斥</span></span><br><span class="line">        semWait(x);</span><br><span class="line">            readcount--;</span><br><span class="line">            <span class="keyword">if</span>(readcount==<span class="number">0</span>)&#123;</span><br><span class="line">                semSignal(wsem);</span><br><span class="line">            &#125;</span><br><span class="line">        semSignal(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        semWait(y);</span><br><span class="line">            writecount++;</span><br><span class="line">            <span class="keyword">if</span>(writecount==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 写进程也会在rsem上排队</span></span><br><span class="line">                semWait(rsem);</span><br><span class="line">            &#125;</span><br><span class="line">        semSignal(y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写操作之间需要互斥</span></span><br><span class="line">        semWait(wsem);</span><br><span class="line">            WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line"></span><br><span class="line">        semWait(y);</span><br><span class="line">            writecount--;</span><br><span class="line">            <span class="comment">// 如果当前没有写进程在执行，则使rsem上排队的读进程开始执行</span></span><br><span class="line">            <span class="keyword">if</span>(writecount==<span class="number">0</span>)&#123;</span><br><span class="line">                semSignal(rsem);</span><br><span class="line">            &#125;</span><br><span class="line">        semSignal(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    readcount = <span class="number">0</span>;</span><br><span class="line">    parbegin(reader,writer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用消息传递解决">6.2、使用消息传递解决</h2>
<h3 id="写者优先">6.2.1、写者优先</h3>
<p>  reader与writer进程代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        rmsg = i;</span><br><span class="line">        send(readrequest,rmsg); <span class="comment">// (请把消息放到mbox中，index=rmsg，此处rmsg作为标识)</span></span><br><span class="line">        receive(mbox[i],rmsg); <span class="comment">// 从mbox中取出要读的消息并存入rmsg，此处rmsg取其本意</span></span><br><span class="line">        READUNIT(); <span class="comment">// 此处</span></span><br><span class="line">        rmsg = i; </span><br><span class="line">        send(finished,rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    message wmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wmsg = j;</span><br><span class="line">        send(writerequest,wmsg);</span><br><span class="line">        receive(mbox[j],wmsg);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        wmsg = j;</span><br><span class="line">        send(finished,wmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   需要一个控制进程来进行读写进程的控制，controller主要功能如下： | count取值 | 处理措施 | | :- | :- | | count &gt; 0 | | | count = 0 | | | count &lt; 0 | |   代码如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">100</span>; <span class="comment">// initialize</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!empty(finished))&#123;</span><br><span class="line">                receive(finished,msg);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(writerequest))&#123;</span><br><span class="line">                receive(writerequest,msg);</span><br><span class="line">                writer od = msg.id;</span><br><span class="line">                count = count<span class="number">-100</span>; <span class="comment">// ?</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(readrequest))&#123;</span><br><span class="line">                receive(readrequest,msg);</span><br><span class="line">                count--;</span><br><span class="line">                send(msg.id,<span class="string">"OK"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            send(writer id,<span class="string">"OK"</span>);</span><br><span class="line">            receive(finished,msg);</span><br><span class="line">            count = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            receive(finished,msg);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E7%BA%BF%E7%A8%8B/" itemprop="url">2.计算机基础/c.操作系统/4.线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><font face="fangsong" size="4"></font></p>
<h1 id="进程和线程">1、进程和线程</h1>
<h2 id="单进程多线程">1.1、单进程多线程</h2>
<h3 id="理解单进程多线程">1.1.1、理解单进程多线程</h3>
<p>  进程是一整个的任务，但是一个任务中可解耦合的更小单元。以个人编程实践为例，多线程允许在一个进程中实现多个功能的并发执行，而单线程只能顺序完成，这带来的感受是不同的（异步操作）。<br>   相比于单线程（线程即进程），多线程具有下列优点： &gt;- 创建以及终止花费时间少，多个线程之间可以共享同一进程的资源，通信时间短 &gt;- 同一进程内线程间切换比进程切换需要的时间少</p>
<p>  可以这样认为：没有多线程之前，当需要创建一个新的<font color="red">较小</font>的任务的时候，需要创建一个新的进程，需要额外的资源与通信代价，这带来的开销是无法忍受的。为了减少这种情况下的开销，引进多线程，让多个线程共享一个进程的资源与某些代码，而这多个线程之间是并发的、异步的（类比多进程并发），这就提升了效率。</p>
<p>  我将多进程+操作系统与多线程+进程作了类比与运用了整体化思想来思考，发现一些有趣的东西：多个进程共享操作系统的一些代码，这提高了计算机的性能（否则如第三章中每个用户进程里面都包含了一个完整的操作系统，这是低效且不可能的）；多线程也与此类似，多个线程共享进程的一部分代码，者减少了重复代码的数量，与此同时多个线程之间通信代价由进程通信时间降低为访存时间。</p>
<p>  多线程也带来了一些问题，比如<font color="red">线程同步</font>等。 ### 1.1.2、线程结构 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E7%BA%BF%E7%A8%8B/单线程与多线程进程模型.png%22"></p>
<h3 id="线程状态与进程状态">1.1.3、线程状态与进程状态</h3>
<p>  可以认为是进程状态中的五状态模型。 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E7%BA%BF%E7%A8%8B/五状态进程模型.png%22"></p>
<h2 id="种类总览">1.2、种类总览</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E7%BA%BF%E7%A8%8B/线程与进程混搭.png%22"></p>
<h1 id="线程分类">2、线程分类</h1>
<p>  线程分为两大类，用户级线程（ULT）与内核级线程（KLT）。二者的区别在于内核能否感知到该线程的存在，可以感知到的即为KLT，感知不到的即为ULT。</p>
<p>  一个多线程的软件（进程）可以有三种管理线程的模式： 1. 纯ULT - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E7%BA%BF%E7%A8%8B/纯ULT.png%22"><br>
- 管理线程的工作完全由应用程序完成，内核意识不到线程的存在 - 通过一个叫线程库的例程包（<font color="red">例如Python的threading、_threads</font>）来“模拟”多线程 - 从处理器的角度来看并不存在线程并行，多线程并行只是在线程库看来的。 - 优点 - 进程不需要为了管理线程而切换到内核模式，进而节省了两次状态转换 - 不打乱底层的操作系统调度程序，可以做到为应用程序量身定做调度算法 - ULT可在任何操作系统中运行，不需要对底层内核进行修改以支持ULT - 缺点 - 在ULT执行一个系统调用时会阻塞该进程中的所有线程 - 在纯ULT策略中，多线程应用程序不能利用多处理技术（即<font color="red">只是应用级多道程序设计，不能并行</font>） - 解决线程阻塞问题的方法 - 将应用程序改成多进程的——不可行 - 使用“套管”技术，将一个产生阻塞的系统调用转化为一个非阻塞的系统调用 2. 纯KLT - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E7%BA%BF%E7%A8%8B/纯KLT.png%22"> - 管理线程的所有工作均由内核完成，应用级没有线程管理代码，只有一个到内核线程设施的应用编程接口（API） - windows是这种方法的一个例子 - 优点 - 内核可以同时把一个进程内的多个线程调度到多个处理器中 - 进程中的一个线程阻塞时，内核可以调度同一个进程中的另一个线程 - <font color="red">内核例程自身也可是多线程的</font> - 缺点 - 在把控制权从一个线程传送到同一个进程内的另一个线程时，需要切换到内核模式</p>
<ol start="3" type="1">
<li>ULT与KLT混合
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E7%BA%BF%E7%A8%8B/ULT与KLT混合.png%22"></li>
<li>例如Solaris</li>
</ul></li>
</ol>
<h1 id="多核与多线程">3、多核与多线程</h1>
<p>  阿姆达定律：<span class="math inline">\(\text{加速比}=\dfrac{\text{在单个处理器上执行程序的时间}}{\text{在N个并行处理器上执行程序的时间}}=\dfrac{1}{(1-f)+f/N}\)</span></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/" itemprop="url">2.计算机基础/c.操作系统/3.进程描述和控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><font size="4" face="fangsong"></font></p>
<h1 id="什么是进程">1、什么是进程</h1>
<ul>
<li>进程映像(process image)
<ul>
<li>进程实体是由程序段、数据段、栈段及进程控制块等部分组成</li>
</ul></li>
<li>进程控制块
<ul>
<li>标识符（identifier）——唯一标识进程</li>
<li>状态（state）——进程的当前状态（运行/就绪/等待）</li>
<li>优先级（priority）——相对于其他进程的优先级别</li>
<li>程序计数器（PC = Program Counter）——即将被执行的下一条程序指令的地址</li>
<li>内存指针（memory pointers）——包括指向程序代码、相关数据和共享内存的指针</li>
<li>上下文数据（context data）——进程被中断时处理器寄存器中的数据</li>
<li>I/O状态信息（I/O status information）——包括显式I/O请求、分配给进程的I/O设备、被解除使用的文件列表等 记帐信息（accounting information）——包括占用处理器时间、时钟数总和、时间限制、账号等</li>
</ul></li>
</ul>
<h1 id="进程状态">2、进程状态</h1>
<h2 id="两状态进程模型">2.1、两状态进程模型</h2>
<p>例如在实验6完成的进程切换就是一种两状态进程模型：运行态&amp;非运行态。所有的进程都在内存中，调度器依据某种规则进行调度。任何时刻只能有一个进程正在执行，未运行的进程在队列中排队（应当是用一个进程标识来作为队列中的项）。 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/两状态进程模型.png%22"></p>
<h2 id="五状态进程模型">2.2、五状态进程模型</h2>
<p>五状态进程模型将未运行态进一步划分为就绪状态与阻塞状态，<font color="red">这避免了让处于阻塞状态的进程进入处理器而浪费处理器的性能</font>，从而提高了效率。<br> 另外该进程模型加入了新建进程与进程退出两个新状态，这使得进程数量动态变化，更加贴合实际。 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/五状态进程模型.png%22"></p>
<p>由于将未运行态的进程进一步划分为就绪态进程和阻塞态进程，这就要求至少两个队列来供处理器调度。 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/单一阻塞队列.png%22"></p>
<p>当阻塞态进程等待的条件得到满足时，例如I/O操作以完成，这时处理器会得到I/O设备的响应，然后将对应进程从阻塞队列移动到就绪队列。<br> 这种方法仍有缺点——不同的进程阻塞的原因是不同的，每当处理器收到响应时，需要在整个队列中遍历查找相应条件的进程（<font color="red">因为可能多个进程因为该原因而阻塞</font>）。改善这种缺陷的方法是设置多条阻塞队列，一条队列中的进程因为同一个原因被阻塞，当阻塞事件完成时，处理器将整条队列转至就绪队列。 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/多条阻塞队列.png%22"></p>
<h2 id="包含挂起状态的进程模型">2.3、包含挂起状态的进程模型</h2>
<p>前面的五状态模型有一个很大的缺点，要知道每个进程占用的资源是比较多的，下图是我自己电脑的任务管理器的视图： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/进程资源占用示例.png%22"> 可以想象，如果每个进程都必须保留在内存中，那么计算机<font color="red">同时运行的进程数将会大大减少</font>。解决这种缺陷的方法是“进程挂起”——将一部分进程实体放到磁盘里面，当执行到该进程时，再将进程从磁盘中取到内存中。 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/六状态进程模型.png%22"> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/七状态进程模型.png%22"> 需要注意的一点是：<font color="red">这里状态的转变都是在处理器看来的，进程本身并不知道自己是什么状态</font>，所更改的也只是进程的一个标识（可以看一下“3、进程描述”部分）而已。</p>
<h1 id="进程描述">3、进程描述</h1>
<h2 id="操作系统的控制结构">3.1、操作系统的控制结构</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/操作系统控制表.png%22"></p>
<h2 id="进程控制结构">3.2、进程控制结构</h2>
<h2 id="进程位置">3.2.1、进程位置</h2>
<h2 id="进程属性">3.2.2、进程属性</h2>
<ol type="1">
<li>进程标识信息
<ul>
<li>进程标识符（process ID）</li>
<li>父进程标识符</li>
<li>用户标识符（user ID）</li>
</ul></li>
<li>进程状态信息/处理器状态信息
<ul>
<li>用户可见寄存器</li>
<li>控制和状态寄存器</li>
<li>栈指针（指向栈顶）</li>
</ul></li>
<li>进程控制信息
<ul>
<li>调度和状态信息（进程状态，优先级，相关调度信息，等待的事件）</li>
<li>数据结构（链接到队列、环或其他结构的信息）</li>
<li>进程间通信</li>
<li>进程特权</li>
<li>存储管理（该进程虚存空间的指针）</li>
<li>资源所有权和使用情况 ## 3.2.3、进程控制块</li>
</ul></li>
<li>通过链表组织
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/PCB表链表逻辑结构.png%22"></li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/PCB表链表物理结构.png%22"></li>
</ul></li>
<li>通过索引表组织
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/PCB表索引表结构.png%22"> # 4、进程控制 ## 4.1、执行模式</li>
</ul></li>
<li>用户模式
<ul>
<li>只能执行非特权指令</li>
<li>用户程序在用户模式下运行（在Intel x86 CPU中对应于保护模式下的特权级[Privilege Level][1~]3）</li>
</ul></li>
<li>系统模式/特权模式/控制模式/内核模式
<ul>
<li>能执行指令全集，具有改变CPU执行状态的能力</li>
<li>操作系统（内核）在系统模式下运行（在Intel x86 CPU中对应于保护模式下的特权级0） ## 4.2、进程创建</li>
</ul></li>
<li>为新进程分配一个唯一的进程标识符</li>
<li>为进程分配空间</li>
<li>初始化进程控制块</li>
<li>设置正确的链接——调度队列</li>
<li>创建或扩充其他数据结构 ## 4.3、进程切换 ### 4.3.1、进程状态切换 进程状态切换是操作系统指定一个进程为运行态，并将CPU控制权交给该进程。<br> 当OS从正在运行的进程那里获得控制权时，可能进行进程切换。导致OS获得控制权的事件（[软/硬或内/外]中断）有如下几种： &gt;1. 中断 &gt; - 时钟中断：时间片到 &gt; - I/O中断：I/O完成，高优先级进程就绪 &gt; - 内存失效：调页时阻塞（所需内存地址不在主存） &gt;2. 陷阱（trap）/异常（exception）：当前执行的指令出现错误（主要指在处理器和内&gt;存内部产生的软中断，一般称为内中断） &gt;3. 系统调用（如申请I/O操作）：用户进程会被置为阻塞态（系统调用一般是通过[由操作&gt;系统规定的]特定中断来实现，如DOS的21h号中断、Linux的80h号中断）</li>
</ol>
<p>进程切换的步骤有下面几步： &gt;1. 保护处理器上下文环境 (到哪里去?) &gt;1. 更新当前处于运行态进程PCB的控制信息（修改状态） &gt;1. 该进程PCB挂入相应队列 (会是哪个队列?) &gt;1. 选择一个就绪进程（涉及多种不同算法） &gt;1. 更新所选进程的PCB（包括状态） &gt;1. 更新存储管理数据结构（涉及地址转换） &gt;1. 恢复被选中进程的处理器上下文环境 (从哪里来?)</p>
<h3 id="进程模式切换">4.3.2、进程模式切换</h3>
<ol type="1">
<li>用户模式→系统模式：
<ul>
<li>唯一途径是通过中断机制（在x86 CPU 中，具体可通过使用调用门指令CALL进行代码转移来实现）</li>
</ul></li>
<li>系统模式→用户模式：
<ul>
<li>可通过修改PSW实现，如指令CHM（x86 CPU中没有此指令，但可通过远程返回指令RETF进行代码转移来实现）</li>
</ul></li>
</ol>
<h1 id="操作系统与进程">5、操作系统与进程</h1>
<ol type="1">
<li>无进程内核：操作系统在所有进程外部执行
<ul>
<li>使用：老操作系统</li>
<li>特点：进程概念仅适用于用户程序，OS代码是在特权模式下工作的独立实体</li>
<li>结构图说明
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/分离的内核.png%22"></li>
</ul></li>
</ul></li>
<li>在用户进程内运行：操作系统作为用户进程的一部分
<ul>
<li>使用：适用于较小计算机的操作系统</li>
<li>特点：OS是用户进程调用的一组例程，OS代码为所有进程映像共享；<font color="red">有点像多个线程共享一个进程的资源</font>，执行OS代码时切换到系统模式（不需进程切换）</li>
<li>结构图说明
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/在用户进程内执行操作系统例程.png%22"></li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/进程映像：在用户进程内执行操作系统.png%22"></li>
</ul></li>
</ul></li>
<li>基于进程的操作系统：操作系统作为一组系统进程来实现，用户进程与系统进程并列
<ul>
<li>使用：现代大多数操作系统</li>
<li>特点：主要内核功能被组织成独立进程，适合多处理器和多机环境</li>
<li>结构图说明
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E5%92%8C%E6%8E%A7%E5%88%B6/操作系统例程作为分离的进程.png%22"></li>
</ul></li>
</ul></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E9%97%AE%E9%A2%98/" itemprop="url">2.计算机基础/c.操作系统/12.文件管理/问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>（12章）把目录项（FCB，文件控制块）中的文件说明（文件描述符）信息分成两个部分后，这两部分分别负责什么功能？</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" itemprop="url">2.计算机基础/c.操作系统/12.文件管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><font size="4" face="fangsong"></font></p>
<h1 id="概述">1. 概述</h1>
<h2 id="文件与文件系统">1.1. 文件与文件系统</h2>
<h2 id="文件结构">1.2. 文件结构</h2>
<blockquote>
<p>Reference：<a href="Reference/Files_Records_and_Fields.pdf">Files_Records_and_Fields.pdf</a> - 域（field） - 记录（record） - 文件（file） - 数据库（database）</p>
</blockquote>
<h2 id="文件管理系统">1.3. 文件管理系统</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/文件系统软件架构.png%22"></p>
<ol type="1">
<li>设备驱动
<ul>
<li>启动设备上的I/O操作，处理I/O请求的完成</li>
</ul></li>
<li>基本文件系统（物理I/O层）
<ul>
<li>处理在磁盘间或磁带系统间交换的数据块</li>
<li>关注这些数据块在辅存和内存缓冲区中的位置</li>
</ul></li>
<li>基本I/O管理程序
<ul>
<li>文件I/O的控制与调度</li>
<li>调度对磁盘和磁带的访问</li>
<li>指定I/O缓冲区</li>
<li>分配辅存</li>
</ul></li>
<li>逻辑I/O
<ul>
<li>处理文件记录</li>
<li>提供一种通用的记录I/O能力，并维护关于文件的基本数据</li>
</ul></li>
<li>访问方法
<ul>
<li>在应用程序和文件系统以及保存数据的设备之间提供了一个标准接口。不同的访问方法反映了不同的文件结构及访问和处理数据的不同方法</li>
</ul></li>
</ol>
<h1 id="文件组织和访问">2. 文件组织和访问</h1>
<blockquote>
<ul>
<li>文件组织：文件中记录的逻辑结构，由用户访问记录的方式确定。</li>
<li>文件在二级存储中的物理组织取决于分块策略和文件分配策略。</li>
</ul>
</blockquote>
<h2 id="文件组织的五个原则">2.1. 文件组织的五个原则：</h2>
<ul>
<li>快速访问</li>
<li>易于修改</li>
<li>节约存储空间</li>
<li>维护简单</li>
<li>可靠性</li>
</ul>
<h2 id="种基本组织">2.2. 5种基本组织：</h2>
<blockquote>
<p>References： - <a href="Reference/数据库的存储结构（文件、记录的组织和索引技术）">数据库的存储结构（文件、记录的组织和索引技术）</a> - <a href="http://www.wlxt.uestc.edu.cn/wlxt/ncourse/sf/web/web/wenjian/wenjian10.1.1.1.htm" target="_blank" rel="noopener">数据结构：文件</a> - <a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6/20862504" target="_blank" rel="noopener">索引顺序文件-百度百科</a> - <a href="https://blog.csdn.net/liang0000zai/article/details/14613329" target="_blank" rel="noopener">文件组织：索引顺序文件</a> ### 2.2.1. 字节序列 - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/字节序列.png%22"> - 构成文件的基本单位是字节，文件是一个无结构的字节序列，其逻辑意义由用户程序解释 - 管理简单，提供很大的灵活性 - 不便于检索 - Unix、MS-DOS中采用</p>
</blockquote>
<h3 id="堆文件这里堆应该是内存组织中的含义--往下增长">2.2.2. 堆文件（这里堆应该是内存组织中的含义--往下增长）</h3>
<ul>
<li>物理组织
<ul>
<li>最简单的文件组织形式，堆文件没有结构，数据按照到达的顺序被收集</li>
<li>记录是变长的，域也可以是变长的，需要能够自我描述</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/堆文件.png%22"></li>
</ul></li>
<li>逻辑组织
<ul>
<li>没有逻辑组织</li>
</ul></li>
<li>修改
<ul>
<li>查找
<ul>
<li>对记录的访问通过穷举查找方式进行，查找速度慢</li>
</ul></li>
<li>插入
<ul>
<li>将新记录放在最后即可</li>
</ul></li>
<li>删除</li>
</ul></li>
<li>适用程序
<ul>
<li>适用于数据难以组织的情况，空间使用情况很好，大多数情况下都不适用</li>
</ul></li>
<li>优缺点
<ul>
<li>优点是简单、节省空间</li>
<li>缺点是穷举查找，速度慢 ### 2.2.3. 顺序文件</li>
</ul></li>
<li>物理组织
<ul>
<li>记录按照<font color="red">关键域</font>的顺序来存储，物理组织直接对应于文件的逻辑组织</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/顺序文件.png%22"></li>
</ul></li>
<li>逻辑组织
<ul>
<li>顺序的，与物理组织一致</li>
</ul></li>
<li>修改
<ul>
<li>查找
<ul>
<li>查找需要顺序查找，查找速度慢（之所以不能够二分查找等操作，是因为二分查找的时候需要将所有项放到内存里，这对于文件来讲显然是不可能的）。</li>
</ul></li>
<li>插入
<ul>
<li>新记录一般放到一个单独的堆文件中，该文件称为<font color="red">日志文件/事务文件</font>，周期性地执行批更新，把日志文件合并到主文件中</li>
<li>还可以组织成链表的形式，此时新记录的插入仅涉及指针操作，而不再要求将新记录放到某个特定的物理块位置</li>
</ul></li>
<li>删除</li>
</ul></li>
<li>适用程序
<ul>
<li>适用于涉及对所有记录的处理的应用</li>
</ul></li>
<li>优缺点
<ul>
<li>缺点是增加了额外的物理和空间开销 ### 2.2.4. 索引顺序文件</li>
</ul></li>
<li>物理组织
<ul>
<li>两个文件：索引文件+主文件，索引有序，主文件有序，静态索引</li>
<li>索引文件中的每条记录由两个域组成：关键域+指向主文件的指针，其中关键域与主文件的关键域相同</li>
<li>每个索引可以对应到一条或多条记录，还可以有多级索引</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/索引顺序文件.png%22"></li>
</ul></li>
<li>逻辑组织
<ul>
<li>有点像桶排序，可以提供快速接近目标记录的能力</li>
</ul></li>
<li>修改
<ul>
<li>查找
<ul>
<li>首先是检索索引，可以顺序、二分查找，最后可能是索引直接对应到记录，也有可能是索引对应到一组记录，然后对记录进行顺序查找。</li>
</ul></li>
<li>插入
<ul>
<li><font color="red">溢出文件</font>类似于顺序文件中使用的日志文件，但溢出文件中的记录可根据它前面记录的指针进行定位</li>
</ul></li>
<li>删除</li>
</ul></li>
<li>适用程序 ### 2.2.5. 索引（无序）文件</li>
<li>物理组织
<ul>
<li>两个文件：索引文件+主文件，索引有序，主文件无序，静态索引</li>
<li>每种关键域都有一个索引表</li>
<li>一条记录的各个关键域分别对应到一个单独的索引，还可以有多级索引</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/索引文件.png%22"></li>
</ul></li>
<li>逻辑组织
<ul>
<li>顺序索引表-&gt;无序主文件记录表</li>
</ul></li>
<li>修改
<ul>
<li>查找（检索）</li>
<li>插入</li>
<li>删除</li>
</ul></li>
<li>适用程序 ### 2.2.6. 直接或散列文件</li>
<li>物理组织</li>
<li>逻辑组织</li>
<li>查找</li>
<li>插入</li>
<li>删除</li>
<li>适用程序</li>
</ul>
<h1 id="b树">3. B树</h1>
<p>  动态索引。 # 4. 文件目录 ## 4.1. 文件目录是什么及其内容 ### 4.1.1. 理解文件目录 1. 文件控制块FCB - 从文件管理角度看，文件由文件体（文件本身的信息，数据）和文件说明组成（元数据） - 文件说明（也称文件控制块，File Control Block，FCB）是操作系统为管理文件而设置的数据结构，<font color="red">存放为管理文件所需的所有相关信息（如FAT文件系统中[32B长]的目录项/文件条目）</font> - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/FCB示例.png%22"> 2. 文件目录 - 把所有的FCB组织在一起，就构成了<font color="red">文件目录，即文件控制块的有序集合，其中一个FCB就称作一个目录项 </font> - 目录的主要功能是用于从文件名到文件内容的映射 3. 目录文件 - 通常将文件目录以文件的形式保存在外存，这个文件就叫目录文件（OS所有） - 该文件可以被各种文件管理例程访问 ### 4.1.2. 文件目录的内容 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/文件目录信息单元.png%22"></p>
<h3 id="目录操作">4.1.3. 目录操作</h3>
<ol type="1">
<li>查找文件</li>
<li>创建文件</li>
<li>删除文件</li>
<li>显示目录：可能会请求文件的全部或部分内容</li>
<li>修改目录：由于某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项</li>
</ol>
<h2 id="文件目录的结构">4.2. 文件目录的结构</h2>
<h3 id="一级目录">4.2.1. 一级目录</h3>
<ul>
<li>结构：整个目录组织是一个线性结构，系统中的所有文件都建立在一张目录表中
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/一级目录.png%22"></li>
</ul></li>
<li>优缺点：
<ul>
<li>优点
<ul>
<li>结构简单，易实现</li>
</ul></li>
<li>缺点
<ul>
<li>文件多时目录检索时间长，从而平均检索时间长</li>
<li>有命名冲突：如多个文件有相同的文件名（不同用户的相同作用的文件）或一个文件有多个不同的文件名（不同用户对同一文件的命名）</li>
</ul></li>
</ul></li>
<li>适用范围：主要用于非常简单的单用户操作系统，如CP/M、DOS 1.0、Orang’S</li>
</ul>
<h3 id="二级目录">4.2.2. 二级目录</h3>
<ul>
<li>结构：在根目录（第一级目录，主文件目录MFD）下，每个用户对应一个目录（第二级目录，用户文件目录UFD ），在用户目录下是该用户的文件，而不再有下级目录
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/二级目录.png%22"></li>
</ul></li>
<li>优缺点
<ul>
<li>优点
<ul>
<li>降低了平均检索时间</li>
<li>部分克服了命名冲突问题</li>
</ul></li>
<li>缺点
<ul>
<li>不利用户对文件的分类管理</li>
</ul></li>
</ul></li>
<li>适用范围：适用于多用户系统，各用户可有自己的专用目录</li>
</ul>
<h3 id="多级目录">4.2.3. 多级目录</h3>
<ul>
<li>结构:采用层次结构，每个用户可在其用户目录下自主创建若干层次的子目录(树)，也称为树型 (tree-like)目录
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/多级目录.png%22"></li>
</ul></li>
<li>优缺点
<ul>
<li>优点
<ul>
<li>层次结构清晰，便于管理和保护，适用于较大的文件系统管理</li>
<li>解决了命名冲突问题</li>
</ul></li>
<li>缺点
<ul>
<li>目录级别太多时，会增加路径检索时间（目录文件存放在外存）</li>
</ul></li>
</ul></li>
<li>适用范围：当前主流OS采用</li>
<li>目录树相关概念
<ul>
<li>目录名：可以修改</li>
<li>目录树：中间结点是目录，叶结点是目录或文件</li>
<li>目录的上下级关系：
<ul>
<li>当前目录 (current directory, working directory工作目录)，一般用单个句点表示：.</li>
<li>父目录 (parent directory) ，一般用双句点表示：..</li>
<li>子目录 (subdirectory)</li>
<li>根目录(root directory) ，一般用单斜线表示：/（类Unix）、（DOS&amp;Windows）</li>
</ul></li>
<li>路径(path)：每个目录或文件，可以由根目录开始依次经由的各级目录名，加上最终的目录名或文件名来表示。一般用斜线分隔：/（类Unix）、（DOS&amp;Windows），如/user/cs、/home/cs、C:</li>
</ul></li>
</ul>
<h3 id="改进的多级目录">4.2.4. 改进的多级目录</h3>
<blockquote>
<p>references： - <a href="https://wenku.baidu.com/view/7f71fd1efbd6195f312b3169a45177232f60e4db.html" target="_blank" rel="noopener">百度文库_题目</a> - <a href="https://books.google.com/books?id=iwqzV9vTuY4C&lpg=PA271&ots=45gE3Jrsok&dq=%E7%AC%A6%E5%8F%B7%E7%9B%AE%E5%BD%95%E9%A1%B9%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E9%A1%B9&hl=zh-CN&pg=PA183#v=onepage&q=%E7%AC%A6%E5%8F%B7%E7%9B%AE%E5%BD%95%E9%A1%B9%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E9%A1%B9&f=false" target="_blank" rel="noopener">计算机操作系统教程</a></p>
</blockquote>
<ol type="1">
<li>结构：为了提高目录检索速度，可把目录项（FCB，文件控制块）中的文件说明（文件描述符）信息分成两个部分：
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/改进的多级目录.png%22"></li>
<li>基本目录项BFCB(主部)：目录或文件的物理地址、存取控制和管理信息等
<ul>
<li>把基本目录项构成的基本文件目录组织成<font color="red">线性结构（逻辑线性、物理线性）</font>，按文件内部标识排序（也称索引节点目录）</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/基本目录项组织.png%22"></li>
</ul></li>
<li>符号目录项(次部)：存储文件的符号名以及相应的标识符（该标识符唯一标识该文件，由系统赋予）等信息。
<ul>
<li>把符号目录项构成的符号文件目录组织成<font color="red">树状结构（逻辑树状、物理线性）</font>，按文件名排序</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/符号目录项组织.png%22"></li>
</ul></li>
</ul></li>
<li>文件目录对应地分成基本文件目录和符号文件目录两个目录。
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/改进的多级目录结构图示例.png%22"></li>
</ul></li>
<li>优缺点
<ul>
<li>便于多用户共享文件</li>
<li>提高了查找效率</li>
</ul></li>
<li>性能比较例子：
<ul>
<li>reference：<a href="https://blog.csdn.net/u011240016/article/details/52861729" target="_blank" rel="noopener">平均磁盘访问次数计算</a></li>
<li>公式：<font color="red"><span class="math inline">\(\dfrac{1}{n}*\sum\limits_{i=1}^{n}{i}=\dfrac{1}{n}*\dfrac{n(n+1)}{2}=\dfrac{n+1}{2}\)</span>，注意是整除。</font></li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/改进的多级目录例子.png%22"></li>
</ul></li>
</ol>
<h1 id="文件共享">5. 5、文件共享</h1>
<h2 id="文件共享-1">5.1. 文件共享</h2>
<h3 id="提供文件共享的方法">5.1.1. 提供文件共享的方法</h3>
<ol type="1">
<li>各用户通过唯一的共享文件路径名访问共享文件
<ul>
<li>访问速度慢，适用于不经常访问的文件共享</li>
</ul></li>
<li>利用多个目录中的不同文件名来描述同一共享文件（即文件别名）
<ul>
<li>访问速度快，但会影响文件系统的树状结构，适用于经常访问的文件共享，同时存在一定的限制</li>
<li>实现方法
<ul>
<li>基于索引节点，也称<font color="red">硬链接（hard link）</font></li>
<li>基于符号链接（symbolic link, shortcut），也成为<font color="red">软链接（soft link）</font> ### 5.1.2. 硬链接（基于索引节点）</li>
</ul></li>
</ul></li>
</ol>
<ul>
<li>基于改进的多级目录结构，将目录内容分为两部分：文件名和索引结点（index node）
<ul>
<li>前者包括文件名和索引结点编号（符号目录项）</li>
<li>后者包括文件的其他内容（包括属主、访问权限、磁盘地址等）（基本目录项）</li>
</ul></li>
<li>通过将多个文件名链接(link)到同一个索引结点，可建立同一个文件的多个彼此平等的别名</li>
<li>别名的数目，被记录在索引结点的链接计数中，若其减至0，则文件被删除</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/硬链接.png%22"></li>
<li>存在问题：
<ul>
<li>记账或配额问题：设B、C共享文件file，C是文件主，若C删除了file而B不删除，则file仍然存在，且仍然是C为file付账，占的也是C的配额</li>
</ul></li>
</ul>
<h3 id="软链接基于符号链接">5.1.3. 软链接（基于符号链接）</h3>
<blockquote>
<p>references: - <a href="https://www.zhihu.com/question/20729978" target="_blank" rel="noopener">知乎：符号连接、软连接、硬连接、快捷方式、副本(copy)之间有何区别和联系？</a> - 建立一个类型为Link的特殊文件，其内容是到另一个目录或文件路径的链接 - 建立符号链接文件，并不影响原文件，实际上它们各是一个文件 - 可以建立任意的别名关系，甚至原文件是在其他计算机上 - 快捷方式本质上就是符号链接 - 缺点 - 空间和时间开销更大 - 如果设置不当，上下级目录关系可能会形成环状</p>
</blockquote>
<h2 id="文件的访问控制">5.2. 文件的访问控制</h2>
<h3 id="文件访问权限">5.2.1. 文件访问权限</h3>
<p>  设置文件访问权限的目的是为了在多个用户间提供有效的文件共享机制，同时对文件进行一定的安全性保护。</p>
<p>  通过两级控制来实现文件访问权限：①、用户验证：当用户登录时，检验其身份；②、存取控制：审查用户的权限、本次操作的合法性。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">访问权限</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">无</td>
<td style="text-align: left;">不知道文件的存在</td>
</tr>
<tr class="even">
<td style="text-align: left;">知道</td>
<td style="text-align: left;">知道文件的存在及其owner</td>
</tr>
<tr class="odd">
<td style="text-align: left;">执行</td>
<td style="text-align: left;">可加载并执行但不能复制</td>
</tr>
<tr class="even">
<td style="text-align: left;">读</td>
<td style="text-align: left;">可以查看/复制内容</td>
</tr>
<tr class="odd">
<td style="text-align: left;">追加</td>
<td style="text-align: left;">可以在文件尾追加数据</td>
</tr>
<tr class="even">
<td style="text-align: left;">更新</td>
<td style="text-align: left;">可以修改/删除/添加数据</td>
</tr>
<tr class="odd">
<td style="text-align: left;">改变保护</td>
<td style="text-align: left;">（文件所有者）修改授予其他用户的访问权限</td>
</tr>
<tr class="even">
<td style="text-align: left;">删除</td>
<td style="text-align: left;">从文件系统中去掉</td>
</tr>
</tbody>
</table>
<p>  文件属主（Owner）具有上述所有权限，并可将不同的访问权限授予不同的用户类</p>
<h3 id="用户类">5.2.2. 用户类</h3>
<ul>
<li>特定用户</li>
<li>用户组</li>
<li>全部 ### 5.2.3. 访问权限和用户类的组合：</li>
<li>访问矩阵（存取控制矩阵）：矩阵的一维（列）是每个目录和文件，另一维（行）是用户范围，每个元素是允许的访问方式
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/访问矩阵.png%22"></li>
</ul></li>
<li>访问策略(policy)：规定每种文件访问方式所允许或禁止的用户范围
<ul>
<li>可以将文件访问方式推广到其他操作如用户管理、备份、网络访问等</li>
</ul></li>
</ul>
<h2 id="共享文件的并发同时访问控制">5.3. 共享文件的并发/同时访问控制</h2>
<p>  加锁解锁，例如读者-写者问题。</p>
<h1 id="记录组块">6. 记录组块</h1>
<p>  记录组块说的是文件的每一条记录在块中的存储情况。 1. 固定组块(fixed blocking) - 记录长度固定，每个块中存放的记录数目也固定——常用但有内部碎片 - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/固定组块.png%22"> 2. 可变长度跨越式组块(variable-length spanned blocking) - 记录长度可变，一个记录允许存放在不同块中——效率高但难实现 - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/可变长度跨越式组块.png%22"> 3. 可变长度非跨越式组块(variable-length unspanned blocking) - 记录长度可变，一个记录只能存放在一个块中——浪费多 - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/可变长度非跨越式组块.png%22"></p>
<h1 id="辅存管理">7. 辅存管理</h1>
<h2 id="文件分配把空间分配给文件">7.1. 文件分配：把空间分配给文件</h2>
<h3 id="基本划分标准">7.1.1. 基本划分标准</h3>
<ol type="1">
<li>是否一次性分配其所需要的最大空间
<ul>
<li>预分配
<ul>
<li>文件创建时必须要声明文件的最大长度</li>
<li>难以可靠估计文件可能的最大长度</li>
<li>倾向于估大文件长度（导致空间浪费）</li>
<li>适用于从不改变的文件</li>
</ul></li>
<li>动态分配
<ul>
<li>需要时才给文件分配空间</li>
<li>需要考虑空闲空间的碎片问题
<ul>
<li>首次适配</li>
<li>最佳适配</li>
<li>最近适配</li>
</ul></li>
</ul></li>
</ul></li>
<li>分区大小
<ul>
<li>大小可变的大规模连续分区</li>
<li>块</li>
</ul></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"> </th>
<th style="text-align: left;">预分配</th>
<th style="text-align: left;">动态分配</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
|<strong>大小可变的大规模连续分区</strong>|
<ol>
<li>
不需要<font color="red">文件分配表（FAT, File Allocation Table）</font>，只需要指向第一块的指针和分配的块的数量（也可以将其看做是特殊的文件分配表）
</li>
<li>
局部性良好但有外部碎片
</li>
</ol>
|
<ol>
<li>
文件分配表动态变化
</li>
<li>
局部性较好但有外部碎片，需要定期执行<font color="red">紧缩算法</font>
</li>
</ol>
<div class="line-block"></div>
|<strong>块</strong>|
<ol>
<li>
需要一个文件分配表，不过文件分配表大小是固定的
</li>
<li>
局部性较差但没有外部碎片
</li>
</ol>
|
<ol>
<li>
文件分配表动态变化
</li>
<li>
局部性较差但没有外部碎片，需要定期执行<font color="red">合并算法</font>
</li>
</ol>
<div class="line-block"></div>
<h3 id="文件分配方法">7.1.2. 文件分配方法</h3>
<ol type="1">
<li>连续分配：大小可变分区+预分配
<ul>
<li>优点是简单，容易实现；局部性较好，对于顺序处理可以一次性读入多个块；检索一个块也比较容易。</li>
<li>缺点是会出现外部碎片，时常需要执行紧缩算法来释放磁盘中的额外空间;文件不能动态增长；另外需要在创建文件时声明文件的大小。</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/连续分配.png%22"></li>
</ul></li>
<li>链式分配：块+动态分配
<ul>
<li>优点是不会出现外部碎片</li>
<li>缺点是局部性交叉，需要周期性地合并文件（<font color="red">以提高局部性</font>）</li>
<li>适合顺序处理的顺序文件</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/链式分配.png%22"></li>
</ul></li>
<li>索引分配：大小可变分区/块+动态分配+文件索引
<ul>
<li>通过增加一级索引来提高检索的效率，是当前最普遍的一种文件分配形式。</li>
<li>优点
<ul>
<li>既能顺序存取，又能随机存取</li>
<li>满足了文件动态增长、插入删除的要求，也能充分利用外存空间</li>
</ul></li>
<li>缺点
<ul>
<li>较多的寻道次数和寻道时间</li>
<li>索引表本身带来了系统开销：内外存空间、存取时间</li>
</ul></li>
<li>基于块来分配
<ul>
<li>使用合并算法进行文件整理时，索引数目不会减少</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/基于块的索引分配.png%22"></li>
</ul></li>
<li>基于大小可变分区来分配
<ul>
<li>执行紧缩算法进行文件整理时，索引数目将会减少</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/基于长度可变分区的索引分配.png%22"></li>
</ul></li>
</ul></li>
</ol>
<h2 id="空闲空间管理跟踪可用空间">7.2. 空闲空间管理：跟踪可用空间</h2>
<ol type="1">
<li>位表（bit table）
<ul>
<li>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，取值0和1分别表示空闲和占用</li>
<li>通过划分子区域以及对每个子区域设置汇总表来提高位表的搜索性能。当文件系统需要大量的连续块时，首先扫描汇总表来发现符合要求的子区域，然后再查找这个子区域
<ul>
<li>事实上与索引的思想是有相似之处的，都是多了高一层的内容</li>
</ul></li>
</ul></li>
<li>链接空闲区
<ul>
<li>每个空闲分区记录指向下一个空闲分区的指针和长度</li>
<li>类比7.1中的FAT和链式分配</li>
<li>与文件分配中的链式分配类似，时间久了以后，磁盘会出现很多很小的碎片</li>
</ul></li>
<li>索引
<ul>
<li>把空闲空间看作一个文件，该文件使用索引分配（即在索引表中记录各个空闲块）</li>
<li>类比文件分配中的索引分配</li>
</ul></li>
<li>空闲块列表
<ul>
<li>每个块关联一个顺序号，所有空闲块的顺序号组成一个列表，该列表称为“空闲块列表”</li>
<li>虽然空闲块列表很大，但是下面两种技术可以把该列表的一小部分保存到内存中
<ul>
<li>栈（LIFO）：需要给文件分配空闲块时，从栈顶取出所需数量的块；解除一个块的分配时,该序号会再次被压入栈中。这样子当栈空了的时候才需要访问磁盘中剩余部分的空闲块列表来获取新的块序号。</li>
<li>队列（FIFO）：与栈类似，区别只是顺序问题。</li>
</ul></li>
</ul></li>
</ol>
<h2 id="卷">7.3. 卷</h2>
<p>  卷本质上是逻辑磁盘。通常一个磁盘会分成几个分区，每个分区都作为一个单独的卷来工作。</p>
<h2 id="可靠性">7.4. 可靠性</h2>
<p>  主要内容是防止出现数据一致性错误。</p>
<p>  请求一个文件分配时，需要执行以下步骤： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/文件分配步骤.png%22"></p>
<p>  这种技术可以防止错误，但是在频繁地分配比较小的块时，会对性能产生重要的影响。</p>
<h1 id="补充">8. 补充：</h1>
<p><br> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/补充1.png%22"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/" itemprop="url">2.计算机基础/c.操作系统/11.IO管理和磁盘调度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T23:44:18+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="io设备">1、IO设备</h1>
<h2 id="io设备分类">1.1、IO设备分类</h2>
<ul>
<li>人可读</li>
<li>机器可读</li>
<li>通信</li>
</ul>
<h2 id="不同io设备间的主要差别">1.2、不同IO设备间的主要差别</h2>
<ul>
<li>数据传送速率
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/典型IO速率.png%22"></li>
</ul></li>
<li>应用</li>
<li>控制的复杂性</li>
<li>传送单位</li>
<li>数据表示</li>
<li>错误条件</li>
</ul>
<h1 id="io功能的组织">2、IO功能的组织</h1>
<h2 id="如何执行io与io功能的发展">2.1、如何执行IO与IO功能的发展</h2>
<p>  IO模块发展主要经历了下列过程： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/IO发展.png%22"></p>
<ul>
<li>程序驱动IO：忙等待，通过处理器实现IO和内存间的数据传送</li>
<li>中断驱动IO：通过中断的方式来提高效率，通过处理器实现IO和内存间的数据传送
<ul>
<li>非阻塞IO指令：继续执行当前进程的后续指令</li>
<li>阻塞IO指令：阻塞当前进程，运行其他进程</li>
</ul></li>
<li>直接存储器访问（DMA）：使用中断，内存与IO数据交换不需要通过处理器
<ul>
<li><font color="red">单独的DMA模块</font>控制内存与IO模块之间的数据交换</li>
</ul></li>
</ul>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/三种技术流程图.png%22"></p>
<h2 id="dma">2.2、DMA</h2>
<blockquote>
<p>reference: - <a href="https://wenku.baidu.com/view/a09c0dabba0d4a7302763aca.html" target="_blank" rel="noopener">DMA技术简介_百度文库</a></p>
</blockquote>
<p>  下图是I/O体系结构的示意图： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/IO体系结构.png%22"></p>
<p>  传统的数据传输数据都是通过处理器来实现内存与IO设备的数据交换的，而DMA则是在I/O设备与内存之间建立起直接的通道： <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/DMA数据传输示意图.png%22"></p>
<p>  DMA有三种结构： - 单总线、I/O分离的DMA结构 - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/单总线、IO分离的DMA结构.png%22"> - DMA模块充当<font color="red">代理处理器</font> - DMA通过程序控制I/O方式（忙等待）在Memory与I/O模块之间交换数据 - 数据传输效率低，每传送一个字需要2个总线周期（传送请求+传送） - 单总线、I/O集成的DMA结构 - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/单总线、IO集成的DMA结构.png%22"> - 比I/O分离的DMA结构少了传送请求这一部分的时间（参照2.1中流程图中的读I/O模块过程）。 - 在I/O分离的DMA结构中，DMA需要读I/O模块状态，然后再指示I/O模块读取（I/O-&gt;DMA），再由DMA向存储器写入 - 在I/O集成的DMA结构中，I/O作为DMA的一部分，读I/O模块状态这一部分不需要占用系统总线，这就为CPU省出了更多的资源 - IO总线的DMA结构（双总线） - <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/IO总线的DMA结构.png%22"> - 所有的I/O模块都在DMA模块之中，各个I/O模块都挂在I/O总线上 - 结构可扩展性强 - 同样的，DMA与I/O模块之间的数据交换脱离系统总线</p>
<h1 id="操作系统设计问题">3、操作系统设计问题</h1>
<h2 id="主要内容">3.1、主要内容：</h2>
<ul>
<li>I/O机制的设计目标
<ul>
<li>效率——最重要（I/O瓶颈），最关注的是磁盘I/O</li>
<li>通用性——统一处理方式，困难
<ul>
<li>处理器看待I/O设备的方式</li>
<li>操作系统管理I/O设备和I/O操作的方式</li>
</ul></li>
</ul></li>
<li>逻辑结构——层次结构、模块化</li>
<li>I/O缓冲——为减小系统开销和提高操作效率，在I/O请求发出之前/后，就/才开始执行数据传送</li>
<li>磁盘调度——磁盘比内存慢4个数量级，磁盘性能与文件系统关系密切</li>
</ul>
<h2 id="io软件设计">3.2、I/O软件设计</h2>
<p>  两个目标： - 效率 - 与处理器和主存相比，大多数I/O设备的速度都相当慢 - 多道程序允许在一些进程等待I/O时运行其他进程 - I/O仍然可能跟不上处理器的速度 - 虚拟内存可解决多道程序设计中的内存不足问题，但是页面交换本身又是I/O操作 - 提高效率技术：I/O缓冲、磁盘调度、磁盘阵列、磁盘高速缓冲等 - 通用性 - 出于简单和避免错误的考虑，人们希望能用一种统一的方式处理所有的设备。 - 低层例程隐藏设备I/O的大部分细节，向进程和高层提供使用设备的通用方式，如read, write, open, close, lock, unlock等——采用层次结构和模块化设计</p>
<h2 id="io软件层次逻辑">3.3、I/O软件层次逻辑</h2>
<p>  下面三个例子展示了不同的I/O组织的模型 <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/IO逻辑结构.png%22"></p>
<ul>
<li>逻辑I/O</li>
<li>设备I/O</li>
<li>调度与控制</li>
</ul>
<h2 id="用户空间的io软件">3.4、用户空间的I/O软件</h2>
<h1 id="io缓冲">4、IO缓冲</h1>
<h2 id="基本相关内容">4.1、基本相关内容</h2>
<blockquote>
<p>  I/O缓冲是指在内存里开辟一块区域，用来接收用户输入和用于计算机输出的数据以减小系统开销和提高外设效率。</p>
</blockquote>
<ul>
<li>缓冲减少了进程的阻塞概率，如果没有I/O缓冲，以控制台程序为例，每一次输入字符都要执行一次中断，这显然是效率低下的。</li>
<li>缓冲技术可提高外设利用率，尽可能使外设处于忙状态</li>
<li>限制：进程的I/O请求不能超过外设的处理能力</li>
</ul>
<p>  两种类型的I/O设备 - block-oriented device - 信息存储的单位是块，传输的单位也是块 - 典型代表是磁盘、SSD、U盘 - stream-oriented device - 以字节流的形式传输数据 - 如终端、打印机、通信端口、鼠标及多数的其他非辅存设备</p>
<h2 id="单方向缓冲">4.2、单方向缓冲</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/IO缓冲.png%22"></p>
<h3 id="单缓冲single-buffer">4.2.1、单缓冲（single buffer）</h3>
<ul>
<li>面向块的：
<ul>
<li>输入传送到缓冲区</li>
<li>需要时缓冲区中的块被移到用户空间</li>
<li>再移入另外一块到缓冲区——预读(read ahead)</li>
</ul></li>
<li>面向流的：
<ul>
<li>每次传送一行/字节（缓冲区用来保存一行/字节的输入/输出）</li>
<li>用户每次输入一行/字节，并以回车表示一行/字节的结束</li>
<li>到终端的输出一次一行/字节</li>
<li>减少了进程挂起的概率，只有当先前的操作还未清空且当前进程需要输出第二行时才会挂起进程</li>
</ul></li>
</ul>
<h3 id="双缓冲double-buffer">4.2.2、双缓冲（double buffer）</h3>
<ul>
<li>使用两个而不是一个系统缓冲区</li>
<li>OS清空或填充一个缓冲区时，进程可以传送数据到另外一个缓冲区（或从另外一个缓冲区取数据）</li>
<li>进一步减少了进程挂起的概率</li>
</ul>
<h3 id="循环缓冲circular-buffer">4.2.3、循环缓冲（circular buffer）</h3>
<ul>
<li>使用超过两个的缓冲区</li>
<li>每个缓冲区是循环缓冲区的一个单元</li>
<li>使I/O操作能跟上（可能爆发式地执行大量I/O的）进程的速度</li>
<li>有限缓冲区的生产者/消费者模型</li>
</ul>
<h2 id="双方向缓冲">4.3、双方向缓冲</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/缓冲池.png%22"></p>
<ul>
<li>缓冲区队列：
<ul>
<li>空闲缓冲区</li>
<li>输入缓冲区</li>
<li>输出缓冲区</li>
</ul></li>
<li>操作：
<ul>
<li>设备输入、CPU读入， CPU写出、设备输出</li>
<li>这些操作互斥访问各个缓冲区队列</li>
</ul></li>
<li>缓冲区整体利用率高</li>
</ul>
<h1 id="磁盘调度">5、磁盘调度</h1>
<h2 id="磁盘性能">5.1、磁盘性能</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/磁盘IO时序.png%22"></p>
<ul>
<li><span class="math inline">\(r\)</span>：旋转速度，单位为<span class="math inline">\(rotates/second\)</span></li>
<li><span class="math inline">\(T_s\)</span>：寻道时间，磁头定位到目标磁道所用时间
<ul>
<li>工业界计算平均寻道时间的方法是对所有可能的寻道时间取平均值。平均寻道时间在3ms~13ms</li>
<li>但是由于应用程序以及磁盘访问调度策略的不同，且磁盘数据具有局部性，所以实际的平均寻道时间通常只有标称数据的25%~33%；由于对同一文件通常会做连续访问，操作系统也会尽量把这些访问一起进行调度，所以这种局部性会增加</li>
</ul></li>
<li><span class="math inline">\(T_r\)</span>：旋转延迟，磁头从目标磁道进一步定位到目标扇区所用时间
<ul>
<li>计算时采用平均值<span class="math inline">\(T_r=\dfrac{1}{2r}\)</span></li>
</ul></li>
<li><span class="math inline">\(T_t\)</span>：传输时间，磁头读取目标扇区（一个或多个）所用时间
<ul>
<li>计算公式为<span class="math inline">\(T_t=\dfrac{b}{rN}\)</span>，其中b表示要传输的字节数，N表示一个磁道中的字节数</li>
</ul></li>
<li>总的平均存取时间为<span class="math inline">\(T_a=T_s+\dfrac{1}{2r}+\dfrac{b}{rN}\)</span></li>
</ul>
<h2 id="磁盘调度策略">5.2、磁盘调度策略</h2>
<blockquote>
<p>  磁盘调度策略是当有多个磁盘读写请求时，如何安排顺序使得整体寻道时间尽量少以提高平均性能。</p>
</blockquote>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/磁盘调度算法.png%22"></p>
<ol type="1">
<li>FIFO（先进先出）
<ul>
<li>使用FIFO,如果只有一些进程需要访向,并且如果大多数请求都是访问簇聚的文件扇区,则有望达到较好的性能。但是,如果有大量进程竞争一个磁盘,这种技术在性能上往往接近于随机调度。因此,需要考虑一些更复杂的调度策略。</li>
</ul></li>
<li>SSTF（最短时间服务优先）
<ul>
<li>每次选择使磁头臂从当前位置开始移动最少的磁盘I/O请求。</li>
<li>存在的问题
<ul>
<li>可能导致某些进程发生“饥饿”( Starvation)。因为只要不断有新进程到达,且其所要访问的磁道与磁头当前所在磁道的距离较近,这种新进程的I/0请求必被优先满足。</li>
<li>磁头臂黏着（根源是单队列）</li>
</ul></li>
</ul></li>
<li>SCAN（扫描算法/电梯算法）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/SCAN图示.png%22"></li>
<li>先沿着一个方向移动，在途中满足所有未完成的请求，然后再往反方向移动，满足剩余的请求。SCAN比较类似于SSTF，不过解决了SSTF中老进程可能饥饿的问题。</li>
<li>存在的问题
<ul>
<li>outer的访问等待时间太长了。</li>
<li>磁头臂黏着（根源是单队列）</li>
</ul></li>
</ul></li>
<li>C-SCAN（<font color="red">循环</font>扫描算法）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/CSCAN图示.png%22"></li>
<li>先沿着一个方向满足途中所有磁盘I/O请求，然后磁头臂回到反方向的末端，再次沿着同一方向移动，解决了SCAN算法中outer等待时间过长的情况。</li>
<li>存在的问题
<ul>
<li>磁头臂黏着（根源是单队列）</li>
</ul></li>
</ul></li>
<li>FSCAN（分步电梯调度算法）
<ul>
<li>使用两个子队列，扫描开始时，所有请求在一个子队列中，另一个子队列为空。</li>
<li>扫描过程中，所有新到的请求都被放在另一个子队列中。</li>
<li>解决了SSTF、SCAN、C-SCAN中的磁头臂黏着现象
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/磁头臂黏着.png%22"></li>
</ul></li>
</ul></li>
<li>N-step-SCAN
<ul>
<li>把磁盘请求队列分成长度为N的子队列，每一次用SCAN处理一个子队列。</li>
<li>在处理一个子队列时，新情求必须加到其他某个队列中。</li>
</ul></li>
</ol>
<h2 id="调度算法示例">5.3、调度算法示例</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/磁盘调度示例.png%22"></p>
<h1 id="raidcontrast-to-sled">6、RAID（contrast to SLED）</h1>
<p>  RAID（Redundant array of independent disks），通过使得磁盘I/O并行化来提高效率。RAID共有7个层级（0~6），这些层级之间没有对应的上下级关系，而是在三个共同原则下的7种不同的架构（常用的有0,1,5,6）： - RAID is a set of physical disk drives viewed in OS as a single logical drive - Data are distributed across the physical drives of an array in a scheme known as striping. - Redundant disk capacity is used to store parity information, which guarantees the recoverability in case of disk failure.</p>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/7-level-RAID.png%22"></p>
<ol type="1">
<li>RAID 0（无冗余）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/RAID0-无冗余.png%22"></li>
<li>严格来讲并不属于RAID家族，因为它并没有冗余</li>
</ul></li>
<li>RAID 1（镜像，mirrored）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/RAID1-镜像.png%22"></li>
<li>两倍的配置，读请求最多可比RAID 0提升一倍，但是写请求没有区别</li>
<li>用于保存重要的系统文件和数据</li>
</ul></li>
<li>RAID 2（通过汉明码冗余）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/RAID2-通过汉明码冗余.png%22"></li>
<li>所有的磁盘成员参与同一个磁盘I/O请求的执行（一次只能执行一个I/O请求）</li>
<li>实际中不适用</li>
</ul></li>
<li>RAID 3（交错位奇偶校验）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/RAID3-交错位奇偶校验.png%22"></li>
<li>所有的磁盘成员参与同一个磁盘I/O请求的执行（一次只能执行一个I/O请求）</li>
<li><font color="red">如何得知哪一个出了错呢？</font></li>
<li>实际中不适用</li>
</ul></li>
<li>RAID 4（块奇偶校验）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/RAID4-块奇偶校验.png%22"></li>
<li>使用了一种独立访问技术，每个磁盘都独立运转</li>
<li>对于任何一种情况,每次的写操作都必须包含奇偶校验磁盘,因此奇偶校验磁盘有可能成为瓶颂。</li>
</ul></li>
<li>RAID 5（块分布奇偶校验）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/RAID5-块分布奇偶校验.png%22"></li>
<li>使用了一种独立访问技术，每个磁盘都独立运转</li>
</ul></li>
<li>RAID 6（双重冗余）
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/RAID6-双重冗余.png%22"></li>
<li>使用了一种独立访问技术，每个磁盘都独立运转</li>
<li>使用两种校验算法，一种是4和5中使用的异或计算P，另一种是独立数据校验算法Q</li>
<li>RAID 6提供了极高的数据可靠性，只有当三个磁盘同时发生错误时，数据才会丢失。</li>
<li>RAID 6每次写都会影响两个校验块，这导致了严重的写性能损失。</li>
</ul></li>
</ol>
<h1 id="磁盘高速缓存内存作为辅存的缓存">7、磁盘高速缓存（内存作为辅存的缓存）</h1>
<p>  有如下两点设计考虑因素 1. 传送数据 or 传送指针（共享内存） 2. 置换算法</p>
<p>  有如下三点性能考虑因素 1. 访问磁盘的局部性 2. 置换算法 3. 缓存大小</p>
<h2 id="传送数据-or-传送指针">7.1、传送数据 or 传送指针</h2>
<h2 id="置换算法">7.2、置换算法</h2>
<ol type="1">
<li>LRU(Least Recently Used)</li>
<li>LFU(Least Frequently Used)
<ul>
<li>受局部性影响，LFU并不是一个好的置换算法</li>
</ul></li>
<li>基于频率的置换算法1
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/基于频率的置换算法1.png%22"></li>
<li>块在逻辑上组织成一个栈，栈顶的一部分作为新区，剩余的作为旧区</li>
<li>性能与LRU差不多,仅有略微的提高</li>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/基于频率的置换算法1的问题.png%22"></li>
</ul></li>
<li>基于频率的置换算法2
<ul>
<li><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/基于频率的置换算法2.png%22"></li>
<li>新区count不变，中间区count每次访问到都会+1，旧区才会被置换</li>
<li>效率比LRU和LFU有显著提高</li>
</ul></li>
</ol>
<h2 id="缓存大小">7.3、缓存大小</h2>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/cache大小1.png%22"> <img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/cache大小2.png%22"></p>
<h1 id="supplement">supplement</h1>
<p><img src="/2021/03/28/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/c.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/OS设计层次.png%22"></p>
<p>课后习题答案：https://max.book118.com/html/2016/0122/33825014.shtm</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ryan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/liuxr98" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ryan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>

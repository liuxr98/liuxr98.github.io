<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="RBlog">
<meta property="article:author" content="Ryan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>RBlog</title>
  








<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/25/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/25/test/" itemprop="url">test</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-25T20:26:17+08:00">
                2021-03-25
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/" itemprop="url">传输层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-25T20:26:17+08:00">
                2021-03-25
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、运输层基本了解"><a href="#1、运输层基本了解" class="headerlink" title="1、运输层基本了解"></a>1、运输层基本了解</h1><p>&emsp;&emsp;运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能；网络层则提供了主机之间的逻辑通信。</p>
<p>&emsp;&emsp;分组在不同协议层级不同叫法：</p>
<ul>
<li>应用层：报文</li>
<li>传输层：报文段</li>
<li>网络层：数据报</li>
</ul>
<p>&emsp;&emsp;UDP与TCP的基本责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务，这称为运输层的多路复用（multiplexing）与多路分解（demultiplexing）。</p>
<p>&emsp;&emsp;TCP采用的技术</p>
<ul>
<li>流量控制</li>
<li>序号</li>
<li>确认</li>
<li>定时器</li>
<li>拥塞控制</li>
</ul>
<p>&emsp;&emsp;TCP与UDP的选择无非考虑两方面因素：速度与可靠性。UDP速度快但可靠性不够，TCP可靠性足够但速度不够因此在应用层选择传输层协议时就要权衡这两方面的需求，从而选择适合自己的协议。</p>
<h1 id="2、多路复用与多路分解"><a href="#2、多路复用与多路分解" class="headerlink" title="2、多路复用与多路分解"></a>2、多路复用与多路分解</h1><h2 id="2-1、基本了解"><a href="#2-1、基本了解" class="headerlink" title="2.1、基本了解"></a>2.1、基本了解</h2><p>&emsp;&emsp;UDP与TCP的基本责任是，将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务，这称为运输层的多路复用（multiplexing）与多路分解（demultiplexing）。</p>
<p>&emsp;&emsp;下图描述了这种关系，其中TCP和UDP的套接字通过套接字标识符（源端口16位+目的端口16位+其他信息）的格式来区分。<br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/多路复用与多路分解.png" alt></p>
<p>&emsp;&emsp;端口号是一个16位的数，其大小在0~65535之间。0~1023范围的端口号称为周知端口号，是受限制的（保留给周知应用层协议来使用）。当开发一个新的应用程序时，必须为其分配一个端口号。</p>
<ul>
<li>熟知端口，数值一般为 0~1023。</li>
<li>登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
<li>客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 </li>
</ul>
<p>&emsp;&emsp;应用程序客户端的端口号由运输层自动地（并且是透明地）分配端口号，而服务器端则分配一个特定的端口号（客户端是在本地就知道的吗？）</p>
<h2 id="2-2、无连接UDP的多路复用与多路分解"><a href="#2-2、无连接UDP的多路复用与多路分解" class="headerlink" title="2.2、无连接UDP的多路复用与多路分解"></a>2.2、无连接UDP的多路复用与多路分解</h2><p>&emsp;&emsp;一个UDP套接字通过一个二元组（destination_ip,destination_port）来全面标识。其中目的IP处于网络层报头中，目的端口号处于运输层报头中。</p>
<p>&emsp;&emsp;但是UDP的运输层报头中也有源端口号，该端口号被接收方作为目的端口号（否则接收方不知道将反馈信息发给谁）。<br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/无连接多路复用与多路分解.png" alt></p>
<h2 id="2-3、面向连接TCP的多路复用与多路分解"><a href="#2-3、面向连接TCP的多路复用与多路分解" class="headerlink" title="2.3、面向连接TCP的多路复用与多路分解"></a>2.3、面向连接TCP的多路复用与多路分解</h2><p>&emsp;&emsp;与UDP的情况相比，TCP增加的属性是，对于同一目的主机，首先根据源IP进行分流，然后再根据不同的目的端口进行分流。同样的，源端口也是用于作为反馈信息的目的端口。<br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/面向连接多路复用与多路分解.png" alt></p>
<h2 id="2-4、Web服务器与TCP"><a href="#2-4、Web服务器与TCP" class="headerlink" title="2.4、Web服务器与TCP"></a>2.4、Web服务器与TCP</h2><p>&emsp;&emsp;Web服务器使用一个进程创建多个线程（大作业就是这么做的）而不是使用多个进程来处理客户的连接请求。</p>
<h1 id="3、无连接运输：UDP"><a href="#3、无连接运输：UDP" class="headerlink" title="3、无连接运输：UDP"></a>3、无连接运输：UDP</h1><h2 id="3-1、UDP传输的特点"><a href="#3-1、UDP传输的特点" class="headerlink" title="3.1、UDP传输的特点"></a>3.1、UDP传输的特点</h2><p>&emsp;&emsp;使用UDP的应用层程序典例是DNS服务，UDP相比TCP，其优点有如下几点：</p>
<ul>
<li>关于何时、发送什么数据的应用层控制更为精细<ul>
<li>TCP有许多额外的措施如拥塞控制，因此数据传输到套接字以后不一定能够及时发送；而UDP则是即传即发</li>
</ul>
</li>
<li>无需连接建立<ul>
<li>减少连接建立时的额外开销，速度更快</li>
</ul>
</li>
<li>无连接状态   <ul>
<li>TCP需要在端系统中维护连接状态（比如接收和发送缓存、拥塞控制参数、序号与确认号的参数等），UDP则不需要，这导致UDP的应用程序能够支持更多的活跃客户。</li>
</ul>
</li>
<li>分组首部开销小<ul>
<li>UDP首部仅有8个字节；TCP首部则有20字节</li>
</ul>
</li>
</ul>
<h2 id="3-2、UDP报文段结构"><a href="#3-2、UDP报文段结构" class="headerlink" title="3.2、UDP报文段结构"></a>3.2、UDP报文段结构</h2><h3 id="3-2-1、报文结构"><a href="#3-2-1、报文结构" class="headerlink" title="3.2.1、报文结构"></a>3.2.1、报文结构</h3><p>&emsp;&emsp;UDP事实上与IP数据包是差不多的，其报文结构如下图所示：<br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/UDP报头结构.png" alt><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/UDP报头位置.png" alt></p>
<p>&emsp;&emsp;根据IP报头中的UDP长度即可得知是UDP报文还是TCP报文。</p>
<h3 id="3-2-2、四个部分"><a href="#3-2-2、四个部分" class="headerlink" title="3.2.2、四个部分"></a>3.2.2、四个部分</h3><p>&emsp;&emsp;UDP报头包括下面四部分（每部分两个字节）：</p>
<ul>
<li>source port：源端口</li>
<li>destination port：目的端口</li>
<li>Length：指示了在UDP报文段中的字节数（首部加数据）</li>
<li>Checksum：用来检查报文在传输时是否有出错</li>
</ul>
<h3 id="3-3-3、UDP校验和"><a href="#3-3-3、UDP校验和" class="headerlink" title="3.3.3、UDP校验和"></a>3.3.3、UDP校验和</h3><p><b>1. 发送方</b></p>
<p>&emsp;&emsp;在发送数据时，为了计算数据包的检验和。应该按如下步骤：</p>
<ol>
<li>把校验和字段设置为0；</li>
<li>把需要校验的数据看成以16位为单位的数字组成，依次进行二进制反码求和（与原码无符号求和取反效果一致）；</li>
<li>把得到的结果存入校验和字段中</li>
</ol>
<p>代码描述如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char16_t</span> <span class="title">checksum</span> <span class="params">(<span class="keyword">char</span> *<span class="built_in">buffer</span>,<span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char32_t</span> cksum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char16_t</span> item;</span><br><span class="line">    While (<span class="built_in">size</span>&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        item = *(<span class="keyword">char16_t</span> *)<span class="built_in">buffer</span>;</span><br><span class="line">        cksum += item;</span><br><span class="line">        <span class="built_in">size</span> -= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">buffer</span> += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    If (<span class="built_in">size</span>) &#123;</span><br><span class="line">        item = *<span class="built_in">buffer</span></span><br><span class="line">        item &lt;&lt;= <span class="number">16</span>;</span><br><span class="line">        cksum += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将32位转换为16位</span></span><br><span class="line">    While (cksum&gt;&gt;<span class="number">16</span>) &#123;</span><br><span class="line">        <span class="comment">// 高16位不是0时，相当于将每一次的回滚累积起来一次性（或者需要几次）解决</span></span><br><span class="line">        cksum = (cksum&gt;&gt;<span class="number">16</span>) + (cksum &amp; <span class="number">0xffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char16_t</span>)(~cksum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>计算过程示例如下：<br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/计算UDP检验和.png" alt></p>
<p><b>2. 接收方</b></p>
<p>&emsp;&emsp;在接收数据时，计算数据包的检验和相对简单，按如下步骤：</p>
<ol>
<li>把首部看成以16位为单位的数字组成，依次进行二进制反码求和，<font color="red">包括校验和字段</font>；</li>
<li>检查计算出的校验和的结果是否有<font color="red">某一位</font>为0；</li>
<li>如果所有位都是1，意味着除了校验位之外其他的算出来跟校验和取反之前是一样的，数据包传输过程中没有出错。否则，校验和就是错误的，协议栈要抛弃这个数据包。</li>
</ol>
<h1 id="4、可靠数据传输原理"><a href="#4、可靠数据传输原理" class="headerlink" title="4、可靠数据传输原理"></a>4、可靠数据传输原理</h1><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/可靠传输服务模型与服务传输.png" alt></p>
<h2 id="4-1、构造可靠数据传输协议"><a href="#4-1、构造可靠数据传输协议" class="headerlink" title="4.1、构造可靠数据传输协议"></a>4.1、构造可靠数据传输协议</h2><h3 id="4-1-1、完全可靠的传输信道（rdt-1-0）"><a href="#4-1-1、完全可靠的传输信道（rdt-1-0）" class="headerlink" title="4.1.1、完全可靠的传输信道（rdt 1.0）"></a>4.1.1、完全可靠的传输信道（rdt 1.0）</h3><p><b>有限状态机FSM如下：</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt1.0.png" alt></p>
<h3 id="4-1-2、仅具有比特差错的传输信道（rdt-2-0，无编号，停等协议）"><a href="#4-1-2、仅具有比特差错的传输信道（rdt-2-0，无编号，停等协议）" class="headerlink" title="4.1.2、仅具有比特差错的传输信道（rdt 2.0，无编号，停等协议）"></a>4.1.2、仅具有比特差错的传输信道（rdt 2.0，无编号，停等协议）</h3><p><b>1. 有限状态机FSM如下：</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.0.png" alt></p>
<p><b>2. 缺陷：ACK/NAK数据包发生比特差错（即发送ACK/NAK的数据包出错-corrupt）。</b></p>
<ul>
<li>解决方案1：引入新型分组，该方案有很多问题，不会采用。</li>
<li>解决方案2：增加足够的检验和比特，使得发送方不仅可以检测差错，还可以恢复差错。在不丢失分组仅发生比特差错的信道中是可行的。</li>
<li>解决方案3：收到含糊不清的ACK或NAK分组时，重传当前分组即可。该方案简单，不过在信道中引入了冗余分组。<font color="red">该方案的困难之处在于接收分组的一方无法区分冗余分组</font>。<ul>
<li>rdt2.1</li>
<li>rdt2.2</li>
</ul>
</li>
</ul>
<h3 id="4-1-3、仅具有比特差错的传输信道（rdt-2-1，停等协议-比特交替协议？）"><a href="#4-1-3、仅具有比特差错的传输信道（rdt-2-1，停等协议-比特交替协议？）" class="headerlink" title="4.1.3、仅具有比特差错的传输信道（rdt 2.1，停等协议/比特交替协议？）"></a>4.1.3、仅具有比特差错的传输信道（rdt 2.1，停等协议/比特交替协议？）</h3><blockquote>
<p>基本特点：数据包有编号。</p>
</blockquote>
<p><b>1. 发送方FSM</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.1发送方.png" alt></p>
<p><b>2. 接收方FSM</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.1接收方.png" alt></p>
<h3 id="4-1-3、仅具有比特差错的传输信道（rdt-2-2，停等协议-比特交替协议？）"><a href="#4-1-3、仅具有比特差错的传输信道（rdt-2-2，停等协议-比特交替协议？）" class="headerlink" title="4.1.3、仅具有比特差错的传输信道（rdt 2.2，停等协议/比特交替协议？）"></a>4.1.3、仅具有比特差错的传输信道（rdt 2.2，停等协议/比特交替协议？）</h3><blockquote>
<p>基本特点：数据包有编号，使用有编号的ACK取代NAK。</p>
</blockquote>
<p><b>1. 发送方FSM</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.2发送方.png" alt></p>
<p><b>2. 接收方FSM</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt2.2接收方.png" alt></p>
<h3 id="4-1-4、具有比特差错与丢包（路由器丢包）的传输信道（rdt-3-0，比特交替协议-amp-停等协议）"><a href="#4-1-4、具有比特差错与丢包（路由器丢包）的传输信道（rdt-3-0，比特交替协议-amp-停等协议）" class="headerlink" title="4.1.4、具有比特差错与丢包（路由器丢包）的传输信道（rdt 3.0，比特交替协议&amp;停等协议）"></a>4.1.4、具有比特差错与丢包（路由器丢包）的传输信道（rdt 3.0，比特交替协议&amp;停等协议）</h3><blockquote>
<p>基本特点：数据包有编号，使用有编号的ACK取代NAK，添加了计时器来处理丢包的情况。rdt3.0是在rdt2.2的基础上改进的。</p>
</blockquote>
<p><b>1. 发送方FSM</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt3.0发送方.png" alt></p>
<p><b>2. 接收方FSM</b></p>
<p>&emsp;&emsp;接收方FSM与rdt2.2是一致的。</p>
<p><b>3. rdt3.0交替执行示例</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt3.0交替执行.png" alt></p>
<p><b>4. rdt3.0错误示例</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt3.0错误例子1.png" alt></p>
<h2 id="4-2、流水线可靠数据传输协议"><a href="#4-2、流水线可靠数据传输协议" class="headerlink" title="4.2、流水线可靠数据传输协议"></a>4.2、流水线可靠数据传输协议</h2><h3 id="4-2-1、流水线可靠数据传输基本了解"><a href="#4-2-1、流水线可靠数据传输基本了解" class="headerlink" title="4.2.1、流水线可靠数据传输基本了解"></a>4.2.1、流水线可靠数据传输基本了解</h3><p><b>1. 单发与多发流水的概念演示</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/停等协议与流水线协议流程比较.png" alt><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/流水线概念.png" alt></p>
<p><b>2. 单发与多发流水的性能比较</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/rdt3.0与流水线比较示例.png" alt></p>
<p>&emsp;&emsp;从上图可以看出，在理想情况下，rdt3.0的发送方利用率为$U_{sender}=\dfrac{L/R}{RTT+L/R}$，而流水线协议的发送方利用率则为$U_{stream_sender}=\dfrac{N<em>L/R}{RTT+N</em>L/R}$（其中$N$表示流水线条数，$RTT$$(Round$ $Trip$ $Time)$表示往返时间，$L$表示发送数据比特数，$R$表示接入链路速率）。</p>
<p><b>3. 流水线技术带来的影响：</b></p>
<ul>
<li>必须增加序号范围</li>
<li>协议的发送方和接收方两端必须具备缓存多个分组的能力</li>
<li>需要设计新的协议来处理丢失、损坏及延时过大的分组<ul>
<li>GBN协议</li>
<li>SR协议</li>
</ul>
</li>
</ul>
<h2 id="4-2-2、回退N步（GBN协议，滑动窗口协议，流水线）"><a href="#4-2-2、回退N步（GBN协议，滑动窗口协议，流水线）" class="headerlink" title="4.2.2、回退N步（GBN协议，滑动窗口协议，流水线）"></a>4.2.2、回退N步（GBN协议，滑动窗口协议，流水线）</h2><p><b>1. 窗口与分组序列：</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/GBN窗口.png" alt></p>
<ul>
<li>四个部分<ul>
<li>$x \in [0, base)$：已经确认发送成功（接收方正确接收到）。</li>
<li>$x \in [base, nextseqnum)$：已经发送但是还没有收到ACK（已经启动的流水线）。</li>
<li>$x \in [nextseqnum, border)$ ：可用但是尚未发送（可启动但未启动的流水线）。</li>
<li>$x \in [border,\infty)$：不可用</li>
</ul>
</li>
<li>窗口<ul>
<li>窗口$window = [base, border)$，长度$N = border-base$，N就是发送方可以连续开启的流水线数目，一般$N=2^k$。</li>
<li>窗口空间中对每个分组进行编号，编号范围为$[0,2^k-1]$。循环使用有限的帧序号。</li>
<li>通过动态调整$N$的大小可以达到拥塞控制的目的。</li>
</ul>
</li>
</ul>
<p><b>2. 工作过程（假设窗口大小不发生改变）：</b></p>
<ul>
<li>发送方<ul>
<li>上层调用<ul>
<li>如果流水线已满，那么拒绝该请求</li>
<li>如果流水线未满，且是多流水过程的开始，那么开启计时器，已开启的流水条数+1（nextseqnum++）</li>
<li>如果流水线未满，且不是多流水过程的开始，那么仅仅设置开启的流水条数+1（nextseqnum++）</li>
</ul>
</li>
<li>收到ACK<ul>
<li>base=ACK_NUM+1（这里体现了累积确认）</li>
</ul>
</li>
<li>超时事件（回退N步）<ul>
<li>检测到超时的一定是当前base处的包，但是后面的位置可能已经接收到对应的ACK。</li>
<li>发送方重传所有已发送但还未被确认过的分组（与之不同的方案是选择重传SR）。</li>
</ul>
</li>
</ul>
</li>
<li>接收方<ul>
<li>接收方不需要维护任何缓存，只需要维护一个变量expectedseqnum（下一个按序接收的分组序号，是绝对序号而不是窗口内编号，用来保证）。</li>
<li>接收到正确按序的包时：<ul>
<li>解析数据、交付数据</li>
<li>生成一个对应该包的ACK（取值为$[0,2^k-1]$）进行发送。</li>
</ul>
</li>
<li>其他情况（错误的包/冗余（不按序）的包）时：发送上一个正确情况时生成的sndpkt（该操作会导致发送方超时重传）。</li>
</ul>
</li>
</ul>
<p><b>3. GBN的FSM（假设窗口大小不发生改变）</b></p>
<p>&emsp;&emsp;首先声明几个编号变量的类型（绝对编号还是窗口编号）：<br>变量名|编号类型<br>:-|:-<br>base|相对编号<br>nextseqnum|相对编号<br>ACK|相对编号<br>expectedseqnum|相对编号，只在接收方中起作用，<font color="red">作用不是很清楚</font><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/GBN发送方.png" alt></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/GBN接收方.png" alt></p>
<p><b>4. 示例</b></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/GBN运行示例.png" alt></p>
<p><b>5. 总结GBN的特点</b></p>
<ul>
<li>使用机制繁多（可靠传输的机制基本都用到了）<ul>
<li>检验和</li>
<li>序号</li>
<li>计时与超时重传</li>
<li>累积确认</li>
</ul>
</li>
<li>网络状况不好时会使得网络环境更加恶化（冗余的包比较多）。</li>
</ul>
<h2 id="4-2-3、选择重传（SR协议）"><a href="#4-2-3、选择重传（SR协议）" class="headerlink" title="4.2.3、选择重传（SR协议）"></a>4.2.3、选择重传（SR协议）</h2><p><b>1. 窗口</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/SR滑窗.png" alt></p>
<p><b>2. 工作流程</b></p>
<ul>
<li>发送方<ul>
<li>上层调用:<ul>
<li>$nextseqnum-send_base=N$：拒绝请求（缓存或者发回上层）。</li>
<li>$nextseqnum-send_base&lt;N$：接收请求，$nextseqnum+1$。</li>
</ul>
</li>
<li>收到ACK（不是累积确认）<ul>
<li>$ACK_num=send_base$：顺序接收到ACK，窗口连续滑动至第一个未接收到ACK的分组处或者$nextseqnum$处。</li>
<li>$ACK_num \in (send_base,nextseqnum)$：标记对应分组已经收到ACK，但是窗口不滑动。</li>
<li>$ACK_num&lt;send_base$：后面的分组ACK回来的比前面的分组ACK要快。 </li>
</ul>
</li>
<li>超时重传（选择重传）<ul>
<li><font color="red">每个分组都要有自己单独的逻辑定时器</font>.可以使用单个硬件定时器模拟多个逻辑定时器来实现。</li>
<li>超时后仅仅重传未收到ACK的分组</li>
</ul>
</li>
</ul>
</li>
<li>接收方<ul>
<li>$Packet_num = rcv_base$：发送ACK，窗口连续滑动至缓存中断处。</li>
<li>$Packet_num \in (rcv_base,rcv_base+N)$：发送ACK，窗口不滑动。</li>
<li>$Packet_num \in [rcv_base-N,rcv_base)$:这是处理冗余情况的措施。考虑最坏情况，接收方收到N个分组，但是发出的N个ACK都丢了。</li>
<li>其他情况：忽略分组（<font color="red">推测：更左边的编号不可能出现而更右边可用来实现流控？</font>）。</li>
</ul>
</li>
</ul>
<p><b>3. 示例</b></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/SR运行示例.png" alt></p>
<p><b>4. 两个窗口的烦恼</b></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/SR问题示例.png" alt></p>
<p>&emsp;&emsp;以上这种情况限制了SR协议的接收方窗口不能大于序号空间的一半。</p>
<p>&emsp;&emsp;<font color="red"><b>证明：</b></font>如果接收方窗口大小为$N/2+1$，那么设想最坏情况，接收方正在等待$[0,N/2]$编号范围内的数据，此时发送方发连续发送编号是$[0,N/2]$的数据，如果接受方完全接受，然后发送的ACK都丢了，那么下一次接收方等待$(N/2,N)\cup\{0,1\}$范围内的数据。而发送方重发发送$[0,N/2]$编号范围内的数据。两个集合有交集$\{0,1\}$，这就导致了错误的发生。</p>
<p>&emsp;&emsp;上面涉及的窗口与序号空间需要格外注意，要分清这两个概念的区别。可以认为<font color="red">序号空间是最大窗口而窗口为活动窗口</font>；也可以从含义上来理解：活动窗口是已经开启的流水线，最大窗口包括已经开启的流水线与还能够开启的流水线。最大窗口包括活动窗口，二者的起始位置是一样的。</p>
<h2 id="4-3、简单总结与需要注意的问题"><a href="#4-3、简单总结与需要注意的问题" class="headerlink" title="4.3、简单总结与需要注意的问题"></a>4.3、简单总结与需要注意的问题</h2><h3 id="4-3-1、机制总结"><a href="#4-3-1、机制总结" class="headerlink" title="4.3.1、机制总结"></a>4.3.1、机制总结</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/可靠数据传输机制总结.png" alt></p>
<h3 id="4-3-2、关键的问题"><a href="#4-3-2、关键的问题" class="headerlink" title="4.3.2、关键的问题"></a>4.3.2、关键的问题</h3><ul>
<li>要确保一个序号x不被重新使用，直到发送方“确信”任何先前发送的序号为x的分组都不再在网络中为止。<ul>
<li>SR协议例子</li>
</ul>
</li>
</ul>
<h1 id="5、拥塞控制原理"><a href="#5、拥塞控制原理" class="headerlink" title="5、拥塞控制原理"></a>5、拥塞控制原理</h1><h2 id="5-1、基本了解"><a href="#5-1、基本了解" class="headerlink" title="5.1、基本了解"></a>5.1、基本了解</h2><p><b>1. 拥塞出现的原因：</b></p>
<ul>
<li>出现资源拥塞的条件：对资源需求的总和 &gt; 可用资源       </li>
<li>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。  </li>
</ul>
<p><b>2. 拥塞控制与流量控制的关系:</b></p>
<ul>
<li>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </li>
<li>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。 </li>
<li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<p><b>3. 拥塞控制的作用:</b><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/拥塞控制的作用.png" alt></p>
<h2 id="5-2、拥塞原因与代价"><a href="#5-2、拥塞原因与代价" class="headerlink" title="5.2、拥塞原因与代价"></a>5.2、拥塞原因与代价</h2><h3 id="5-2-1、两个发送方和一台具有无穷大缓存的路由器"><a href="#5-2-1、两个发送方和一台具有无穷大缓存的路由器" class="headerlink" title="5.2.1、两个发送方和一台具有无穷大缓存的路由器"></a>5.2.1、两个发送方和一台具有无穷大缓存的路由器</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/拥塞情况1.png" alt></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/拥塞性能1.png" alt></p>
<h3 id="5-2-2、两个发送方和一台具有有限缓存的路由器"><a href="#5-2-2、两个发送方和一台具有有限缓存的路由器" class="headerlink" title="5.2.2、两个发送方和一台具有有限缓存的路由器"></a>5.2.2、两个发送方和一台具有有限缓存的路由器</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/拥塞情况2.png" alt></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/拥塞性能2.png" alt></p>
<h3 id="5-2-3、4个发送方和具有有限缓存的多台路由器及多条路径"><a href="#5-2-3、4个发送方和具有有限缓存的多台路由器及多条路径" class="headerlink" title="5.2.3、4个发送方和具有有限缓存的多台路由器及多条路径"></a>5.2.3、4个发送方和具有有限缓存的多台路由器及多条路径</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/拥塞情况3.png" alt></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/拥塞性能3.png" alt></p>
<h3 id="5-2-4、总结"><a href="#5-2-4、总结" class="headerlink" title="5.2.4、总结"></a>5.2.4、总结</h3><ul>
<li>原因<ul>
<li>出错重传</li>
<li>丢包重传</li>
<li>提前超时</li>
</ul>
</li>
<li>代价<ul>
<li><font color="red">（情形1）分组的到达速率接近链路容量时，分组经历巨大的排队时延</font></li>
<li>（情形2，超时重传）发送方必须执行重传以补偿因为缓存溢出而丢失的分组</li>
<li>（情形2，大时延重传）发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本</li>
<li>（情形3，初始数据丢失）当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。<ul>
<li>“割肉”的明智选择</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-3、拥塞控制方法"><a href="#5-3、拥塞控制方法" class="headerlink" title="5.3、拥塞控制方法"></a>5.3、拥塞控制方法</h2><h3 id="5-3-1、端到端拥塞控制"><a href="#5-3-1、端到端拥塞控制" class="headerlink" title="5.3.1、端到端拥塞控制"></a>5.3.1、端到端拥塞控制</h3><p>&emsp;&emsp;端系统通过观察网络的行为来推断是否发生了阻塞，并采取相应的行动。TCP的拥塞控制就是端到端拥塞控制。</p>
<h3 id="5-3-2、网络辅助的拥塞控制"><a href="#5-3-2、网络辅助的拥塞控制" class="headerlink" title="5.3.2、网络辅助的拥塞控制"></a>5.3.2、网络辅助的拥塞控制</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/网络辅助的拥塞控制.png" alt></p>
<ul>
<li>直接反馈：使用阻塞分组。</li>
<li>经由接收方的网络反馈：修改分组的指示位，然后B收到后向A发送拥塞信息。此方法至少需要1个RTT。</li>
</ul>
<h2 id="5-4、网络拥塞的拥塞控制例子：ATM-ABR拥塞控制"><a href="#5-4、网络拥塞的拥塞控制例子：ATM-ABR拥塞控制" class="headerlink" title="5.4、网络拥塞的拥塞控制例子：ATM ABR拥塞控制"></a>5.4、网络拥塞的拥塞控制例子：ATM ABR拥塞控制</h2><h1 id="6、面向连接的运输：TCP"><a href="#6、面向连接的运输：TCP" class="headerlink" title="6、面向连接的运输：TCP"></a>6、面向连接的运输：TCP</h1><h2 id="6-1、TCP连接"><a href="#6-1、TCP连接" class="headerlink" title="6.1、TCP连接"></a>6.1、TCP连接</h2><ul>
<li>连接是逻辑上的连接，是保留在端系统中的连接，中间的网络层并不会维持TCP的连接状态。</li>
<li>连接的建立即是发送数据之前先互相发送某些预备报文段，以建立确保数据传输的参数。</li>
<li>TCP连接提供全双工服务，即A-&gt;B和B-&gt;A均可传输数据。</li>
<li>TCP连接总是点对点的（UDP传输时则是1对1，1对多，多对1，多对多均可）。</li>
<li>两个名词：MSS-最大报文段长度（应用层数据长度）；MTU-链路层最大传输单元（链路层帧最大长度）</li>
<li>TCP连接的组成：两台主机上的缓存、变量、进程连接的套接字</li>
<li>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。<ul>
<li>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</li>
</ul>
</li>
<li>TCP 的可靠传输机制用字节的序号进行控制。<font color="red">TCP 所有的确认都是基于序号而不是基于报文段</font>。</li>
</ul>
<h2 id="6-2、TCP报文段结构"><a href="#6-2、TCP报文段结构" class="headerlink" title="6.2、TCP报文段结构"></a>6.2、TCP报文段结构</h2><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/TCP报文结构.png" alt></p>
<ul>
<li>序号（32）与确认号（32）：用于实现可靠数据传输</li>
<li>首部长度（4）：选项字段也算作TCP首部，故TCP首部长度是可变的。如果选项字段为空，那么TCP长度为20字节。</li>
<li>保留未用（6）：</li>
<li>标志字段（6）：<ul>
<li>URG：实践中未使用</li>
<li>ACK：<font color="red">表示该序号之前的所有字节都收到了</font></li>
<li>PSH： 该标志置位时，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。实践中未使用</li>
<li>RST：用于复位相应的TCP连接。</li>
<li>SYN：建立连接</li>
<li>FIN：终止连接</li>
</ul>
</li>
<li>接受窗口字段（16）：用于流量控制</li>
<li>检验和（16）：</li>
<li>紧急数据指针（16）：实践中未使用</li>
</ul>
<h2 id="6-3、往返时间的估计与超时"><a href="#6-3、往返时间的估计与超时" class="headerlink" title="6.3、往返时间的估计与超时"></a>6.3、往返时间的估计与超时</h2><h3 id="6-3-1、估计往返时间"><a href="#6-3-1、估计往返时间" class="headerlink" title="6.3.1、估计往返时间"></a>6.3.1、估计往返时间</h3><p><b>1. RTT估算</b></p>
<p>&emsp;&emsp;采用指数加权移动平均来估计：$EstimatedRTT_{initial}=SampleRTT_{first}$$EstimatedRTT = (1-\alpha)<em>EstimatedRTT + \alpha </em>SampleRTT$。<br>&emsp;&emsp;$\alpha$的参考值是0.125，即：$EstimatedRTT = 0.875<em>EstimatedRTT + 0.125 </em>SampleRTT$。</p>
<p><b>2. RTT偏差(振荡范围)估算</b></p>
<p>&emsp;&emsp;也采用指数加权移动平均来估计：$DevRTT_{initial}=0$$DevRTT=(1-\beta)DevRTT + \beta<em>|SampleRTT-EstimatedRTT|$<br>&emsp;&emsp;$\beta$的参考值是0.25，即：$DevRTT=0.75</em>DevRTT + 0.25*|SampleRTT-EstimatedRTT|$。</p>
<h3 id="6-3-2、设置和管理重传超时间隔"><a href="#6-3-2、设置和管理重传超时间隔" class="headerlink" title="6.3.2、设置和管理重传超时间隔"></a>6.3.2、设置和管理重传超时间隔</h3><p>&emsp;&emsp;应当假定一个区间，应当有概率论的知识来证明事件P（未丢包且落在此区间之外）是一个小概率事件。<br>&emsp;&emsp;该区间右边界估计方法如下：$TimeoutInterval=EstimateRTT+4*DevRTT$<br>&emsp;&emsp;推荐的$TimeoutInterval$初始值为1秒。</p>
<h2 id="6-4、可靠数据传输"><a href="#6-4、可靠数据传输" class="headerlink" title="6.4、可靠数据传输"></a>6.4、可靠数据传输</h2><h3 id="6-4-1、一个高度简化的TCP发送方"><a href="#6-4-1、一个高度简化的TCP发送方" class="headerlink" title="6.4.1、一个高度简化的TCP发送方"></a>6.4.1、一个高度简化的TCP发送方</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NextSeqNum = InitialSeqNumber</span><br><span class="line">SendBase = InitialSeqNumber</span><br><span class="line"></span><br><span class="line">loop (forever) &#123;</span><br><span class="line">    switch(event)&#123;</span><br><span class="line">        <span class="symbol">event:</span> &lt;data received from application above&gt; &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="symbol">event:</span> &lt;timer timeout&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="symbol">event:</span> &lt;ACK received, with ACK field value of y&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-2、超时间隔加倍"><a href="#6-4-2、超时间隔加倍" class="headerlink" title="6.4.2、超时间隔加倍"></a>6.4.2、超时间隔加倍</h3><p>&emsp;&emsp;如果超时，那么超时间隔加倍；如果收到ACK或者上层数据，那么超时间隔通过6.3.2中的公式$TimeoutInterval=EstimateRTT+4*DevRTT$推算得到。</p>
<p>&emsp;&emsp;缺点是超时间隔会比较长，效率比较低.</p>
<h3 id="6-4-3、快速重传"><a href="#6-4-3、快速重传" class="headerlink" title="6.4.3、快速重传"></a>6.4.3、快速重传</h3><p>&emsp;&emsp;冗余ACK：</p>
<ul>
<li>收到的数据包出错，发送最后一个分组的ACK</li>
<li>中间数据包丢包，收到之后的数据包时，发送最后一个分组的ACK</li>
</ul>
<p>&emsp;&emsp;当连续收到三个冗余ACK时，即便没有超时也会重传。</p>
<h3 id="6-4-4、差错恢复机制"><a href="#6-4-4、差错恢复机制" class="headerlink" title="6.4.4、差错恢复机制"></a>6.4.4、差错恢复机制</h3><p>&emsp;&emsp;介于GBN和SR之间，ACK确认是累积的，不过接收方会缓存失序但有效的分组。这样子使得接收方只需要一个计时器，ACK确认比较方便。当发送方重传时，如果填补了空隙，那么接收方就会发送最后面数据的序号，这时中间这一段就不需要发送方发送了。</p>
<h2 id="6-5、流量控制"><a href="#6-5、流量控制" class="headerlink" title="6.5、流量控制"></a>6.5、流量控制</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">变量名</th>
<th style="text-align:left">变量含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$LastByteRead$</td>
<td style="text-align:left">接收方的应用进程从缓存中读出的数据流的最后一个字节的编号</td>
</tr>
<tr>
<td style="text-align:left">$LastByteRcvd$</td>
<td style="text-align:left">从网络中到达的并且已经放入接收方缓存中的数据流的最后一个字节的编号</td>
</tr>
<tr>
<td style="text-align:left">$LastByteSent$</td>
<td style="text-align:left">已经发送的数据最后一个字节的编号</td>
</tr>
<tr>
<td style="text-align:left">$LastByteAcked$</td>
<td style="text-align:left">已经确认发送成功的数据最后一个字节的编号</td>
</tr>
<tr>
<td style="text-align:left">$RcvBuffer$</td>
<td style="text-align:left">接收方缓存大小</td>
</tr>
<tr>
<td style="text-align:left">$rwnd$</td>
<td style="text-align:left">接收方窗口，$rwnd=RcvBuffer - [LastByteRcvd-LastByteRead]$</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/接收窗口与接收缓存.png" alt></p>
<p>两个必须成立的不等式：</p>
<ul>
<li>$LastByteRcvd-LastByteRead \leqslant RcvBuffer$</li>
<li>$LastByteSent-LastByteAcked \leqslant rwnd$</li>
</ul>
<p>需要注意的问题：</p>
<ul>
<li>当接收方窗口大小为0时，发送方仍然会发送只有一个字节数据的报文段（否则发送方将会阻塞）。</li>
</ul>
<h2 id="6-6、TCP连接管理"><a href="#6-6、TCP连接管理" class="headerlink" title="6.6、TCP连接管理"></a>6.6、TCP连接管理</h2><ul>
<li>第1步：客户端发送特殊的TCP报文段<ul>
<li>SYN报文段</li>
<li>随机选取一个序号</li>
</ul>
</li>
<li>第2步：服务器t去SYN字段，为该TCP连接分配缓存和变量，并向该客户TCP发送允许连接的报文段。服务器最后也要选择自己的初始序号。该报文段称为SYNACK字段。</li>
<li>第3步：客户向服务器发送的允许连接建立报文，该报文段可以携带数据。</li>
</ul>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/TCP三次握手.png" alt></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/TCP四次挥手.png" alt></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/客户端典型的TCP状态序列.png" alt></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/服务器端典型的TCP状态序列.png" alt></p>
<h2 id="6-7、TCP拥塞控制"><a href="#6-7、TCP拥塞控制" class="headerlink" title="6.7、TCP拥塞控制"></a>6.7、TCP拥塞控制</h2><h3 id="6-7-1、基本了解"><a href="#6-7-1、基本了解" class="headerlink" title="6.7.1、基本了解"></a>6.7.1、基本了解</h3><p>&emsp;&emsp;三个关键问题：</p>
<ul>
<li>一个TCP发送方如何限制它想起连接发送流量的速率？   <ul>
<li>$LastByteSent-LastByteAcked \leqslant min\{cwnd,rwnd\}$（$cwnd$表示拥塞窗口）</li>
</ul>
</li>
<li>一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞呢？<ul>
<li>超时</li>
<li>三个冗余ACK</li>
</ul>
</li>
<li>当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢？</li>
</ul>
<h3 id="6-7-2、TCP拥塞控制算法"><a href="#6-7-2、TCP拥塞控制算法" class="headerlink" title="6.7.2、TCP拥塞控制算法"></a>6.7.2、TCP拥塞控制算法</h3><p><b>1. 各部分主要思想</b></p>
<p>&emsp;&emsp;主要有三部分：</p>
<ul>
<li>慢启动<ul>
<li>$cwnd$值初始化为1个$MSS$（初始发送速率约为$\dfrac{MSS}{RRT}$）</li>
<li>发送速率翻倍增长，即$cwnd^+ = 2*cwnd$。</li>
</ul>
</li>
<li>拥塞避免<ul>
<li>每次增加为1个$MSS$</li>
</ul>
</li>
<li>快速恢复</li>
</ul>
<p><b>2. FSM描述</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">digraph FSM&#123;</span><br><span class="line">    rankdir&#x3D;TB</span><br><span class="line">    overlap &#x3D; false</span><br><span class="line">    splines &#x3D; true</span><br><span class="line">    node[shape&#x3D;plain,label&#x3D;&quot;&quot;]</span><br><span class="line">    edge[color&#x3D;white,arrowhead&#x3D;vee]</span><br><span class="line">    size &#x3D; &quot;20,20&quot;  </span><br><span class="line">    1-&gt;2-&gt;3</span><br><span class="line">    node[shape&#x3D;doublecircle]</span><br><span class="line">    a[label&#x3D;&quot;慢启动&quot;,color&#x3D;blue]</span><br><span class="line">    b[label&#x3D;&quot;拥塞避免&quot;,color&#x3D;purple]</span><br><span class="line">    c[label&#x3D;&quot;快速恢复&quot;,color&#x3D;green]</span><br><span class="line">    &#123;rank&#x3D;same 1,a&#125;</span><br><span class="line">    &#123;rank&#x3D;same 2,b,c&#125;</span><br><span class="line">    a -&gt; b[label&#x3D;&quot;cwnd&gt;&#x3D;ssthresh&quot;,color&#x3D;blue,fontcolor&#x3D;blue]</span><br><span class="line">    a -&gt; a[label&#x3D;&quot;正常，\ncwnd&#x3D;2*cwnd&quot;,color&#x3D;blue,fontcolor&#x3D;blue]</span><br><span class="line">    a -&gt; a[label&#x3D;&quot;正常，\ncwnd&#x3D;2*cwnd&quot;,color&#x3D;blue,fontcolor&#x3D;blue]</span><br><span class="line">    b -&gt; a[label&#x3D;&quot;超时,ssthresh&#x3D;cwnd&#x2F;2\ncwnd&#x3D;MSS&quot;,color&#x3D;purple,fontcolor&#x3D;purple]</span><br><span class="line">    b -&gt; c[label&#x3D;&quot;三个冗余ACK，ssthresh&#x3D;cwnd&#x2F;2，\ncwnd&#x3D;ssthresh+3*MSS&quot;,color&#x3D;purple,fontcolor&#x3D;purple]</span><br><span class="line">    b -&gt; b[label&#x3D;&quot;正常，cwnd+&#x3D;MSS*(MSS&#x2F;cwnd)&quot;,color&#x3D;purple,fontcolor&#x3D;purple]</span><br><span class="line">    c -&gt; a[label&#x3D;&quot;超时，ssthresh&#x3D;cwnd&#x2F;2\ncwnd&#x3D;MSS&quot;,color&#x3D;green,fontcolor&#x3D;green]</span><br><span class="line">    c -&gt; c[label&#x3D;&quot;冗余，cwnd+&#x3D;MSS&quot;,color&#x3D;green,fontcolor&#x3D;green]</span><br><span class="line">    c -&gt; b[label&#x3D;&quot;正常，cwnd+&#x3D;ssthresh&quot;,color&#x3D;green,fontcolor&#x3D;green]</span><br><span class="line">    a -&gt; c[label&#x3D;&quot;三个冗余ACK，ssthresh&#x3D;cwnd&#x2F;2，\ncwnd&#x3D;ssthresh+3*MSS&quot;,color&#x3D;blue,fontcolor&#x3D;blue]</span><br><span class="line">    a -&gt; a[label&#x3D;&quot;&quot;,color&#x3D;blue,fontcolor&#x3D;blue]</span><br><span class="line">    b -&gt; b[label&#x3D;&quot;冗余ACK，dupACKcount++&quot;,color&#x3D;purple,fontcolor&#x3D;purple]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/TCP拥塞控制的FSM描述.png" alt></p>
<p><b>3. 举例</b></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E4%BC%A0%E8%BE%93%E5%B1%82/TCP拥塞控制示例.png" alt></p>
<h3 id="6-7-3、吞吐量"><a href="#6-7-3、吞吐量" class="headerlink" title="6.7.3、吞吐量"></a>6.7.3、吞吐量</h3><h3 id="6-7-4、公平性"><a href="#6-7-4、公平性" class="headerlink" title="6.7.4、公平性"></a>6.7.4、公平性</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/" itemprop="url">物理层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-25T20:26:17+08:00">
                2021-03-25
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、物理层的基本概念"><a href="#1、物理层的基本概念" class="headerlink" title="1、物理层的基本概念"></a>1、物理层的基本概念</h1><p>主要的任务：确定与传输媒体的接口的一些特性</p>
<ul>
<li>机械特性<ul>
<li>指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li>
</ul>
</li>
<li>电气特性<ul>
<li>指明在接口电缆的各条线上出现的电压的范围。</li>
</ul>
</li>
<li>功能特性<ul>
<li>指明某条线上出现的某一电平的电压表示何种意义。</li>
</ul>
</li>
<li>过程特性<ul>
<li>指明对于不同功能的各种可能事件的出现顺序。 </li>
</ul>
</li>
</ul>
<p>术语：</p>
<ul>
<li>数据(data)——运送消息的实体。</li>
<li>信号(signal)——数据的电气的或电磁的表现。 </li>
<li>“模拟的”(analogous)——代表消息的参数的取值是连续的。 </li>
<li>“数字的”(digital)——代表消息的参数的取值是离散的。 </li>
<li>码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</li>
<li>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</li>
<li>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 </li>
<li>基带信号（即基本频带信号）<ul>
<li>来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li>
<li>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制(modulation)。   </li>
</ul>
</li>
<li>带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 </li>
<li>码元<ul>
<li>数字通信中一个基带波形所对应的二进制码组</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/码元与比特.png" alt="码元与比特"></li>
</ul>
</li>
<li>比特：一个码元中每一个二进制位</li>
<li>带宽<ul>
<li>信道最高信号频率-信道最低信号频率，单位是Hz</li>
<li>带宽=频带宽度，并非平时所说的表示速率的带宽</li>
</ul>
</li>
<li>信道容量（比特速率）<ul>
<li>信道能无错误传送的最大信息率。单位是bit/s(bps)。它代表每秒能传送的最大信息量，或者说小于这个数的信息率必能在此信道中无错误地传送。</li>
<li>表示传输速率（俗称的带宽）</li>
</ul>
</li>
</ul>
<h1 id="2、数据通信的基础知识"><a href="#2、数据通信的基础知识" class="headerlink" title="2、数据通信的基础知识"></a>2、数据通信的基础知识</h1><h2 id="2-1、数据通信系统的模型"><a href="#2-1、数据通信系统的模型" class="headerlink" title="2.1、数据通信系统的模型"></a>2.1、数据通信系统的模型</h2><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/数据通信系统.png" alt="数据通信系统"></p>
<h2 id="2-2、信号调制"><a href="#2-2、信号调制" class="headerlink" title="2.2、信号调制"></a>2.2、信号调制</h2><p>&emsp;&emsp;基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制(modulation)。</p>
<p>&emsp;&emsp;最基本的二元制调制方法有以下几种：</p>
<ul>
<li>调幅(AM)：载波的振幅随基带数字信号而变化。 </li>
<li>调频(FM)：载波的频率随基带数字信号而变化。</li>
<li>调相(PM)：载波的初始相位随基带数字 信号而变化。 </li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/几种调制方法.png" alt="几种调制方法"></li>
<li><font color="red">正交振幅调制QAM？</font>

</li>
</ul>
<h2 id="2-3、信道的极限容量与极限信息传输速率"><a href="#2-3、信道的极限容量与极限信息传输速率" class="headerlink" title="2.3、信道的极限容量与极限信息传输速率"></a>2.3、信道的极限容量与极限信息传输速率</h2><ol>
<li>理想条件下(无噪声干扰)的码元的传输速率极限（码元速率，奈氏准则）<ul>
<li>受限因素<ul>
<li>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li>
<li>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</li>
</ul>
</li>
<li>公式：$CB \leqslant 2W\ (Baud/s)$<ul>
<li>CC：码元容量/传输速率</li>
<li>W：链路频带宽度（以Hz为单位）</li>
<li>码元的最大传输速率与物理链路的带宽(Hz)线性关系</li>
</ul>
</li>
</ul>
</li>
<li>理想条件下(无噪声干扰)的极限信息传输速率（比特速率，奈氏准则推导而得）<ul>
<li>受限因素<ul>
<li>信道的频带宽度</li>
<li>编码方案</li>
</ul>
</li>
<li>公式：$Cb \leqslant 2Wlog_2M\ (bit/s)$<ul>
<li>一个码元最多包含比特数由编码方案决定：$log_2M (bit/Baud)$，$M$表示编码进制数</li>
</ul>
</li>
</ul>
</li>
<li>带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（比特速率，香农公式）<ul>
<li>受限因素<ul>
<li>信道频带宽度</li>
<li>信噪比</li>
<li><font color="red">编码方案？</font></li>
</ul>
</li>
<li>公式：$Cb \leqslant Wlog_2(1+S/N) \ (bit/s)$<ul>
<li>W：链路频带宽度/信道的带宽（以Hz 为单位）</li>
<li>S：信道内所传信号的平均功率；</li>
<li>N：信道内部的高斯噪声功率。</li>
<li>S/N称为信噪比</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="3、物理层下面的传输媒体"><a href="#3、物理层下面的传输媒体" class="headerlink" title="3、物理层下面的传输媒体"></a>3、物理层下面的传输媒体</h1><h2 id="3-1、导引型传输媒体"><a href="#3-1、导引型传输媒体" class="headerlink" title="3.1、导引型传输媒体"></a>3.1、导引型传输媒体</h2><ul>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光缆<h2 id="3-2、非导引型传输媒体"><a href="#3-2、非导引型传输媒体" class="headerlink" title="3.2、非导引型传输媒体"></a>3.2、非导引型传输媒体</h2></li>
<li>电离层反射——短波通信</li>
<li>微波</li>
</ul>
<h1 id="4、信道复用技术"><a href="#4、信道复用技术" class="headerlink" title="4、信道复用技术"></a>4、信道复用技术</h1><h2 id="4-1、频分复用、时分复用和统计时分复用"><a href="#4-1、频分复用、时分复用和统计时分复用" class="headerlink" title="4.1、频分复用、时分复用和统计时分复用"></a>4.1、频分复用、时分复用和统计时分复用</h2><h2 id="4-2、波分复用"><a href="#4-2、波分复用" class="headerlink" title="4.2、波分复用"></a>4.2、波分复用</h2><p>&emsp;&emsp;即是光的频分复用。</p>
<h2 id="4-3、码分复用"><a href="#4-3、码分复用" class="headerlink" title="4.3、码分复用"></a>4.3、码分复用</h2><p>&emsp;&emsp;每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。</p>
<h1 id="5、数字传输系统"><a href="#5、数字传输系统" class="headerlink" title="5、数字传输系统"></a>5、数字传输系统</h1><p>&emsp;&emsp;旧的数字传输系统存在着许多缺点</p>
<ul>
<li>速率标准不统一。</li>
<li>不是同步传输。</li>
</ul>
<p>同步光纤网SONET</p>
<p>同步数字系列SDH</p>
<h1 id="6、宽带接入技术"><a href="#6、宽带接入技术" class="headerlink" title="6、宽带接入技术"></a>6、宽带接入技术</h1><h2 id="6-1、ADSL技术"><a href="#6-1、ADSL技术" class="headerlink" title="6.1、ADSL技术"></a>6.1、ADSL技术</h2><p>DSL(Digital Subscriber Line,数字用户线)的几种类型：</p>
<ul>
<li>ADSL(Asymmetric Digital Subscriber Line)：非对称数字用户线<ul>
<li>ADSL 技术就把0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</li>
<li>ADSL 的极限传输距离与数据率以及用户线的线径都有很大的关系（用户线越细，信号传输时的衰减就越大），而所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。<ul>
<li>例如，0.5 毫米线径的用户线，传输速率为1.5 ~ 2.0 Mb/s 时可传送5.5 公里，但当传输速率提高到6.1 Mb/s 时，传输距离就缩短为3.7 公里。</li>
<li>如果把用户线的线径减小到0.4毫米，那么在6.1 Mb/s的传输速率下就只能传送2.7公里</li>
</ul>
</li>
<li>上行和下行带宽做成不对称的。上行指从用户到ISP，而下行指从ISP 到用户。</li>
<li>ADSL 在用户线（铜线）的两端各安装一个ADSL 调制解调器。</li>
<li>我国目前采用的方案是离散多音调DMT (Discrete Multi-Tone)调制技术。这里的“多音调”就是“多载波”或“多子信道”的意思。<ul>
<li>DMT 调制技术采用频分复用的方法，把40 kHz 以上一直到1.1 MHz 的高端频谱划分为许多的子信道，其中25 个子信道用于上行信道，而249 个子信道用于下行信道。</li>
<li>每个子信道占据4 kHz 带宽（严格讲是4.3125 kHz），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/DMT分频.png" alt="DMT分频"></li>
</ul>
</li>
<li>ADSL 的数据率<ul>
<li>由于用户线的具体条件往往相差很大（距离、线径、受到相邻用户线的干扰程度等都不同），因此ADSL 采用自适应调制技术使用户线能够传送尽可能高的数据率。</li>
<li>当ADSL 启动时，用户线两端的ADSL 调制解调器就测试可用的频率、各子信道受到的干扰情况，以及在每一个频率上测试信号的传输质量。</li>
<li>ADSL 不能保证固定的数据率。对于质量很差的用户线甚至无法开通ADSL。</li>
<li>通常下行数据率在32 kb/s 到6.4 Mb/s 之间，而上行数据率在32 kb/s 到640 kb/s 之间。</li>
</ul>
</li>
<li>ADSL 的组成<ul>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E7%89%A9%E7%90%86%E5%B1%82/ADSL组成.png" alt="ADSL组成"></li>
</ul>
</li>
<li>第二代ADSL<ul>
<li>通过提高调制效率得到了更高的数据率。例如，ADSL2 要求至少应支持下行8 Mb/s、上行800 kb/s的速率。而ADSL2+ 则将频谱范围从1.1 MHz 扩展至2.2 MHz，下行速率可达16 Mb/s（最大传输速率可达25 Mb/s），而上行速率可达800 kb/s。</li>
<li>采用了无缝速率自适应技术SRA (Seamless Rate Adaptation)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。</li>
<li>改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义。</li>
</ul>
</li>
</ul>
</li>
<li>HDSL(High speed DSL)：高速数字用户线</li>
<li>SDSL(Single-line DSL)：1对线的数字用户线</li>
<li>VDSL(Very high speed DSL)：甚高速数字用户线</li>
<li>DSL：ISDN 用户线。</li>
<li>RADSL(Rate-Adaptive DSL)：速率自适应DSL，是ADSL 的一个子集，可自动调节线路速率）。</li>
</ul>
<h2 id="6-2、光纤同轴混合网（HFC网）"><a href="#6-2、光纤同轴混合网（HFC网）" class="headerlink" title="6.2、光纤同轴混合网（HFC网）"></a>6.2、光纤同轴混合网（HFC网）</h2><h2 id="6-3、FTTx-技术"><a href="#6-3、FTTx-技术" class="headerlink" title="6.3、FTTx 技术"></a>6.3、FTTx 技术</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/" itemprop="url">网络层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-25T20:26:17+08:00">
                2021-03-25
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="整体结构图"><a href="#整体结构图" class="headerlink" title="整体结构图"></a>整体结构图</h1><blockquote>
<p><font size="4"> 路由结构 </font><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/路由结构.png" alt="路由结构"></p>
<p><font size="4"> 路由选择 </font><br><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/路由选择总结.png" alt="路由选择总结"></p>
</blockquote>
<h1 id="1、路由工作原理"><a href="#1、路由工作原理" class="headerlink" title="1、路由工作原理"></a>1、路由工作原理</h1><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/路由器体系结构.png" alt="路由器体系结构"></p>
<h2 id="1-1、输入端口"><a href="#1-1、输入端口" class="headerlink" title="1.1、输入端口"></a>1.1、输入端口</h2><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/输入端口处理.png" alt="输入端口处理"></p>
<h3 id="1-1-1、转发"><a href="#1-1-1、转发" class="headerlink" title="1.1.1、转发"></a>1.1.1、转发</h3><p>&emsp;&emsp;转发表是由路由选择处理器计算和更新的，但转发表的一份影子副本通常会被存放在每个输入端口。有了影子副本，转发决策就能在每个输入端口本地做出，无需调用中央路由选择处理器，因此避免了集中式处理的瓶颈。<br>&emsp;&emsp;表查找基本点：</p>
<ul>
<li>最长段前缀匹配。</li>
<li>必须用硬件进行查找以达到应有的转发速率。</li>
<li>对大型转发表应使用超出简单线性搜索的技术。</li>
</ul>
<h3 id="1-1-2、输入端口排队"><a href="#1-1-2、输入端口排队" class="headerlink" title="1.1.2、输入端口排队"></a>1.1.2、输入端口排队</h3><p>&emsp;&emsp;由于$R_{line} &lt; R_{switch}$，所以排队微不足道，一般不会出现缓存不够而丢包的情况。<br>&emsp;&emsp;尽管输入端口的排队一般不会引起丢包的问题，但是可能影响效率，如下图中的情况：</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/输入端口排队举例.png" alt="输入端口排队举例"></p>
<p>&emsp;&emsp;该情况称为排头阻塞（HOL阻塞），一种更有效率的方式是，输入端口2中的两个分组同时能够发出去，这可以通过增设多条队列来实现。</p>
<p>另外，HOL阻塞可能带来丢包。[Karol 1987]指出，由于HOL阻塞，只要输入链路上的分组到达速率达到其容量的58%，在某些假设前提下，输入队列长度将无限制的增大（不严格地讲，这等同于说将出现大量的丢包）。</p>
<h2 id="1-2、交换结构"><a href="#1-2、交换结构" class="headerlink" title="1.2、交换结构"></a>1.2、交换结构</h2><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/交换结构.png" alt="交换结构"></p>
<p>&emsp;&emsp;将路由器的输入端口和输出端口相连接，该结构完全包含在路由器中，是路由器中的网络。</p>
<p>&emsp;&emsp;简单推测其抽象结构应如下所示：</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/交换结构抽象示意图.png" alt="交换结构抽象示意图"></p>
<h3 id="1-2-1、经内存交换"><a href="#1-2-1、经内存交换" class="headerlink" title="1.2.1、经内存交换"></a>1.2.1、经内存交换</h3><p>&emsp;&emsp;特点：</p>
<ul>
<li>是最简单、最早的路由器结构（是传统的计算机），交换工作在CPU的直接控制下完成。</li>
<li>如同传统计算机中的I/O操作，分组到达时会发送中断信号给路由选择处理器。路由选择处理器提取报头中的目的地址，将分组复制到对应的输出缓存中。</li>
<li>转发吞吐量依赖于内存带宽且必然小于内存带宽的一半。</li>
<li>不能同时转发两个分组（从OS角度理解）。</li>
</ul>
<p>&emsp;&emsp;许多现代路由器也通过内存进行交换，但多是经共享内存进行转发的，可将其理解为共享内存的多处理器。输入线路卡可以将分组写进适当的输出端口的内存中。</p>
<h3 id="1-2-2、经总线交换"><a href="#1-2-2、经总线交换" class="headerlink" title="1.2.2、经总线交换"></a>1.2.2、经总线交换</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/经总线交换的流程示意.png" alt="经总线交换的流程示意"></p>
<p>&emsp;&emsp;特点：</p>
<ul>
<li>交换带宽受总线效率影响</li>
<li>每次只能转发一个分组</li>
</ul>
<p>&emsp;&emsp;对于运行在小型局域网和企业网中的路由器来说，通过总线交换通常是足够的。</p>
<h3 id="1-2-3、经互联网络交换（以纵横式交换机为例）"><a href="#1-2-3、经互联网络交换（以纵横式交换机为例）" class="headerlink" title="1.2.3、经互联网络交换（以纵横式交换机为例）"></a>1.2.3、经互联网络交换（以纵横式交换机为例）</h3><p>&emsp;&emsp;由$2N$条总线组成的互联网络，用于连接$N$个输入端口和$N$个输出端口，有$N^2$个交叉点。<br>&emsp;&emsp;特点：</p>
<ul>
<li>一种并行（2个分组的输入端与输出端都不一样），两种串行（2个分组的输入端相同或者输出端相同）。</li>
<li><p>在任意时刻，交换结构控制器可以控制交叉点的断开和闭合。<br>问题：</p>
</li>
<li><p>如果在交叉点冲突了呢？怎么办？</p>
</li>
<li>如何选择要闭合的交叉点呢？（路径如何选择？）</li>
</ul>
<h2 id="1-3、输出端口"><a href="#1-3、输出端口" class="headerlink" title="1.3、输出端口"></a>1.3、输出端口</h2><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/输出端口处理.png" alt="输出端口处理"></p>
<h3 id="1-3-1、输出端口排队"><a href="#1-3-1、输出端口排队" class="headerlink" title="1.3.1、输出端口排队"></a>1.3.1、输出端口排队</h3><p>&emsp;&emsp;由于$R_{line} &gt; R_{switch}$，所以队列过长将会导致丢包（“在网络中丢弃”，“被路由器丢弃”）现象。这是一个很重要的问题。</p>
<h3 id="1-3-2、分组调度程序（Chapter7有更深入的讲解）"><a href="#1-3-2、分组调度程序（Chapter7有更深入的讲解）" class="headerlink" title="1.3.2、分组调度程序（Chapter7有更深入的讲解）"></a>1.3.2、分组调度程序（Chapter7有更深入的讲解）</h3><p>&emsp;&emsp;简单的调度策略有下面几种：</p>
<ul>
<li>缓存足够<ul>
<li>先来先服务（FCFS）</li>
<li>加权公平排队（WFQ）  </li>
</ul>
</li>
<li>缓存不足<ul>
<li>弃尾（drop-tail）：丢弃到达的分组</li>
<li>删除一个或多个已排队的分组</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;主动队列管理算法（AQM）：在缓存填满前便丢弃（或在首部加标记）一个分组，以便向发送方提供一个拥塞信号。随机早期检测（RED）是一种得到最广泛研究和实现的AQM算法：</p>
<ul>
<li>$Length_{queue} &lt; min_{th}$：新到分组被接纳进队列</li>
<li>$Length_{queue} \in [min_{th},max_{th}]$：新到分组以某种概率被丢弃</li>
<li>$Length_{queue} &gt; max_{th}$：新到分组被丢弃</li>
</ul>
<h2 id="1-4、路由选择处理器（路由控制平面）"><a href="#1-4、路由选择处理器（路由控制平面）" class="headerlink" title="1.4、路由选择处理器（路由控制平面）"></a>1.4、路由选择处理器（路由控制平面）</h2><p>&emsp;&emsp;其主要功能如下：</p>
<ul>
<li>执行路由选择协议</li>
<li>维护路由选择表以及连接的链路状态信息</li>
<li>为路由器计算转发表</li>
<li>网络管理功能（chapter 9）</li>
</ul>
<p>&emsp;&emsp;路由选择平面全部驻留并运行在路由器中的路由选择处理器上（大部分是这样子的），因此网络范围的路由选择平面是分布式的。今天因特网路由器以及路由选择算法正是以这种方式运行的。</p>
<h2 id="1-5、路由表与转发表"><a href="#1-5、路由表与转发表" class="headerlink" title="1.5、路由表与转发表"></a>1.5、路由表与转发表</h2><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/路由表与转发表.png" alt="路由表与转发表"></p>
<h3 id="1-5-1、路由表（RIB-Routing-Info-Base）"><a href="#1-5-1、路由表（RIB-Routing-Info-Base）" class="headerlink" title="1.5.1、路由表（RIB:Routing Info Base）"></a>1.5.1、路由表（RIB:Routing Info Base）</h3><p>&emsp;&emsp;路由信息最终要存储在用于路由器的主机或者专业路由器上，存放这些信息的地方称为路由表。其中包含三元素：目标地址，掩码，下一跳。<br>&emsp;&emsp;做计网实验时截取的一个实例如下图所示：</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/路由表实例.PNG" alt="路由表实例"></p>
<h3 id="1-5-2、转发表（FIB-Forwarding-Info-Base）"><a href="#1-5-2、转发表（FIB-Forwarding-Info-Base）" class="headerlink" title="1.5.2、转发表（FIB:Forwarding Info Base）"></a>1.5.2、转发表（FIB:Forwarding Info Base）</h3><p>&emsp;&emsp;数据包到达路由器的时候，要根据“指示”前往特定的端口，类似交换机的地址信息表，路由器上存放这个“指示”的地方叫做转发表。<br>&emsp;&emsp;当 IP 路由从 RIB 拷贝到 FIB 时，它们的下一跳信息被明确地分析出来，包括下一跳的具体端口，以及如果到下一跳有多条路径时，每条路径的具体端口。</p>
<h3 id="1-5-3、二者的联系与不同"><a href="#1-5-3、二者的联系与不同" class="headerlink" title="1.5.3、二者的联系与不同"></a>1.5.3、二者的联系与不同</h3><ul>
<li>转发表直接作用于数据包，而路由表是转发表生成的依据，转发表通过路由表生成。一个特定的进程可以通过使用路由表中的信息，加上自身的主机方面的信息（比如网卡等信息）加以综合，得到一张转发表。<font color="red">路由信息和主机是没有任何关系的，它只描述网络链路状态和方向。</font></li>
<li>转发表的结构应当使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化</li>
<li>路由表总是由软件实现的，而转发表可由硬件实现</li>
<li>二者建立的目的不同：构造转发表的目的是为了优化转发分组时查找网络号的过程；路由表则是为了计算拓扑结构的改变；</li>
<li>两表存储的信息是不同的，路由表只存储三元素-目标，掩码，下一跳；而转发表存储更详细的信息，比如输出端口信息，比如标记信息等。</li>
<li>转发表描述了主机方面的信息，在主机内部将一个数据包从一个端口导向另一端口，而路由表描述网络信息，将数据包从一个机器导向另一机器。</li>
</ul>
<h1 id="2、虚电路与数据报网络"><a href="#2、虚电路与数据报网络" class="headerlink" title="2、虚电路与数据报网络"></a>2、虚电路与数据报网络</h1><p>&emsp;&emsp;Network-layer connection and connectionless services in many ways parallel transport-layer connection-oriented and connectionless services. For example, a network-layer connection service begins with handshaking between the source and destination hosts; and a network-layer connectionless service does not have any handshaking preliminaries.</p>
<p>&emsp;&emsp;<font color="red">因特网是一个数据报网络，但是其他一些网络，如ATM、帧中继网络则是虚电路网络。</font></p>
<h2 id="2-1、虚电路网络"><a href="#2-1、虚电路网络" class="headerlink" title="2.1、虚电路网络"></a>2.1、虚电路网络</h2><blockquote>
<p>仅在网络层提供连接服务的计算机网络称为虚电路网络。</p>
</blockquote>
<p>&emsp;&emsp;一条虚电路的组成如下：</p>
<ul>
<li>源和目的主机之间的路径（即一系列链路和路由）</li>
<li>VC号：沿着该路径的每段链路的一个号码</li>
<li>沿着该路径的每台路由器中的<font color="red">转发表表项</font></li>
</ul>
<p>&emsp;&emsp;虚电路的工作过程中有如下三个阶段：</p>
<ul>
<li>虚电路建立</li>
<li>数据传送</li>
<li>虚电路拆除</li>
</ul>
<p>&emsp;&emsp;虚电路中的转发表大致如下图所示（虚电路的工作过程就是各个中继路由器通过转发表进行VC号的修改，最终使得数据报能够发送到目的地）：</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/虚电路转发表.png" alt="虚电路转发表"></p>
<p>&emsp;&emsp;虚电路连接建立与运输层连接建立的区别：</p>
<ul>
<li>传输层连接的建立仅涉及两个端系统，中间路由器对此连接完全不知情</li>
<li>网络成虚电路连接的建立涉及到两个端系统之间的所有路由器，每台路由器都完全知道<font color="red">经过它的所有虚电路</font>。</li>
</ul>
<p>&emsp;&emsp;相关内容还有信令报文和信令协议。</p>
<h2 id="2-2、数据报网络"><a href="#2-2、数据报网络" class="headerlink" title="2.2、数据报网络"></a>2.2、数据报网络</h2><blockquote>
<p>仅在网络层提供无连接服务的计算机网络称为虚电路网络。因特网是数据报网络。</p>
</blockquote>
<p>&emsp;&emsp;数据报网络通过最长前缀进行匹配，一个转发表示例如下：</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/数据报转发表.png" alt="数据报转发表"></p>
<h2 id="2-3、比较虚电路网络与数据报网络"><a href="#2-3、比较虚电路网络与数据报网络" class="headerlink" title="2.3、比较虚电路网络与数据报网络"></a>2.3、比较虚电路网络与数据报网络</h2><ul>
<li>更新：数据报网络中通常1~5分钟更新一次转发表；而虚电路网络中路由器一旦有所改变就会更新转发表。</li>
<li>顺序：数据报网络分组到达不保证顺序；虚电路网络分组有序交付。</li>
<li>容错性：如果虚电路网络发生故障，则经过故障点的数据全部丢失；而数据报网络发生故障时，分组的发送可绕过故障点。 </li>
<li>速度：虚电路网络的分组不需要路由选择，所以分组传送时速度较快；数据报网络则需要路由选择处理，速度较慢。</li>
<li>使用情景：<ul>
<li>虚电路分组交换适用于端系统之间长时间的数据交换，尤其是在频繁的，但每次传送数据又很短的交互式会话情况下，免去了每个分组中地址信息的额外开销，但是每个网络节点却需要负担维持虚电路表的开销。</li>
<li>数据报免去了呼叫建立过程，在分组传输数量不多的情况下要比虚电路简单灵活。每个数据报可以临时根据网络中的流量情况选取不太拥挤的链路，不象虚电路中的每个分组必须按照连接建立时的路径传送。每个节点没有额外开销，但每个分组在每个节点都要经过路由选择处理，会影响传送速度。</li>
</ul>
</li>
</ul>
<h1 id="3、因特网中的转发与编址：IPv4与IPv6"><a href="#3、因特网中的转发与编址：IPv4与IPv6" class="headerlink" title="3、因特网中的转发与编址：IPv4与IPv6"></a>3、因特网中的转发与编址：IPv4与IPv6</h1><h2 id="3-1、数据报格式"><a href="#3-1、数据报格式" class="headerlink" title="3.1、数据报格式"></a>3.1、数据报格式</h2><h3 id="3-1-1、格式"><a href="#3-1-1、格式" class="headerlink" title="3.1.1、格式"></a>3.1.1、格式</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IPv4数据报格式.png" alt="IPv4数据报格式"></p>
<h3 id="3-1-2、IP分片"><a href="#3-1-2、IP分片" class="headerlink" title="3.1.2、IP分片"></a>3.1.2、IP分片</h3><ul>
<li>路由器只拆不装，保证网络核心的简单原则。</li>
</ul>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IP分片.png" alt="IP分片"></p>
<h2 id="3-2、IPv4编址"><a href="#3-2、IPv4编址" class="headerlink" title="3.2、IPv4编址"></a>3.2、IPv4编址</h2><ul>
<li>因特网的地址分配策略被称为无类别域间路由选择（CIDR）。</li>
<li>路由聚合：使用单个网络前缀通告多个网络的能力。<ul>
<li>组织变更</li>
</ul>
</li>
</ul>
<h2 id="3-3、主机与子网如何得到地址"><a href="#3-3、主机与子网如何得到地址" class="headerlink" title="3.3、主机与子网如何得到地址"></a>3.3、主机与子网如何得到地址</h2><h3 id="3-3-1、获取一块地址"><a href="#3-3-1、获取一块地址" class="headerlink" title="3.3.1、获取一块地址"></a>3.3.1、获取一块地址</h3><h3 id="3-3-2、获取主机地址：动态主机配置协议（DHCP）"><a href="#3-3-2、获取主机地址：动态主机配置协议（DHCP）" class="headerlink" title="3.3.2、获取主机地址：动态主机配置协议（DHCP）"></a>3.3.2、获取主机地址：动态主机配置协议（DHCP）</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/DHCP服务场景.png" alt="DHCP服务场景"></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/DHCP的CS交互.png" alt="DHCP的CS交互"></p>
<h3 id="3-3-3、网络地址转换（NAT）"><a href="#3-3-3、网络地址转换（NAT）" class="headerlink" title="3.3.3、网络地址转换（NAT）"></a>3.3.3、网络地址转换（NAT）</h3><ul>
<li>内网可以访问外网（内网请求数据时外网才能发给内网，否则就不行），外网无法访问内网。</li>
<li>NAT使能路由器在外界看起来更像是一个具有单一IP地址的单一设备。</li>
<li>NAT使能路由器处理了第四层的数据（端口）。</li>
</ul>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/网络地址转换示例.png" alt="网络地址转换示例"></p>
<p>NAT穿越：</p>
<ul>
<li>连接反转（使用中继，可用于P2P应用中）：A在外网，B在一个NAT内网，C在外网，且C与B已经建立了TCP连接，那么A可以经过C与B建立TCP连接（A最初不能与B直接通信的原因在于A无法获知B的专用地址与共用地址的映射关系）。</li>
<li>通用即插即用（UPnP，打洞）：P2P应用程序可以请求NAT产生一个“洞”，即是获取一个专用地址到公用地址的映射。要求NAT和主机都是UPnP兼容的。</li>
</ul>
<h2 id="3-4、因特网控制保温协议（ICMP）"><a href="#3-4、因特网控制保温协议（ICMP）" class="headerlink" title="3.4、因特网控制保温协议（ICMP）"></a>3.4、因特网控制保温协议（ICMP）</h2><h2 id="3-5、IPv6"><a href="#3-5、IPv6" class="headerlink" title="3.5、IPv6"></a>3.5、IPv6</h2><ul>
<li>IPv6/IPv4节点：拆封IPv6数据包，添加IPv4报头<ul>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/双协议节点.png" alt="双协议节点"></li>
<li>这种方案是有问题的，问题在于IPv6-&gt;IPv4-&gt;IPv6的过程中IPv6的一些信息会丢失。</li>
</ul>
</li>
<li>建隧道：IPv6数据包直接作为IPv4数据包的数据流（即再加一层IPv4报头）<ul>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/隧道.png" alt="隧道"></li>
</ul>
</li>
</ul>
<h1 id="4、路由选择算法基础"><a href="#4、路由选择算法基础" class="headerlink" title="4、路由选择算法基础"></a>4、路由选择算法基础</h1><p>&emsp;&emsp;路由选择算法分类:</p>
<ul>
<li>全局式路由选择算法 vs 分散式路由选择算法</li>
<li>静态路由选择算法 vs 动态路由选择算法</li>
<li>负载敏感路由选择算法 vs 负载迟钝路由选择算法</li>
</ul>
<h2 id="4-1、链路状态路由选择算法（LS算法）"><a href="#4-1、链路状态路由选择算法（LS算法）" class="headerlink" title="4.1、链路状态路由选择算法（LS算法）"></a>4.1、链路状态路由选择算法（LS算法）</h2><h3 id="4-1-1、算法描述"><a href="#4-1-1、算法描述" class="headerlink" title="4.1.1、算法描述"></a>4.1.1、算法描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Variable declare:</span><br><span class="line">    src: the source node</span><br><span class="line">    G: the graph</span><br><span class="line">    N: the set of the nodes in G</span><br><span class="line">    N&#39;: the set of the nodes whose shortest distance to src have been found</span><br><span class="line">    c(w,v): the distance between w and v, while w and v are neighbors</span><br><span class="line">    D[NodeNum]: record the distance between src and other nodes</span><br><span class="line"></span><br><span class="line">Initialization:</span><br><span class="line">    N&#39; &#x3D; &#123;src&#125;</span><br><span class="line">    D(src) &#x3D; 0</span><br><span class="line">    for v in G.nodes:</span><br><span class="line">        if v is a neighbor of src:</span><br><span class="line">            D(v) &#x3D; c(u,v)</span><br><span class="line">        else:</span><br><span class="line">            D(v) &#x3D; INF</span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line">    find w not in set N&#39; such that D(w) is a minimum</span><br><span class="line">    add w to N&#39;</span><br><span class="line">    for v in w.neighbors:</span><br><span class="line">        D(v) &#x3D; min&#123;D(v),D(w)+c(w,v)&#125;</span><br><span class="line">until N&#39; &#x3D; N</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2、问题"><a href="#4-1-2、问题" class="headerlink" title="4.1.2、问题"></a>4.1.2、问题</h3><p>&emsp;&emsp;拥塞控制导致的路由震荡——<font color="red">路径不停地反向更改</font>。</p>
<p>解决方案：</p>
<ul>
<li>强制链路费用不依赖于所承载的流量——这是不可接受的</li>
<li><font color="red">确保并非所有路由器都同时运行LS算法</font><ul>
<li>自同步现象<ul>
<li>避免：让每台路由器发送链路通告的时间随机化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-2、距离向量路由选择算法（DV算法）"><a href="#4-2、距离向量路由选择算法（DV算法）" class="headerlink" title="4.2、距离向量路由选择算法（DV算法）"></a>4.2、距离向量路由选择算法（DV算法）</h2><h3 id="4-2-1、运作机制"><a href="#4-2-1、运作机制" class="headerlink" title="4.2.1、运作机制"></a>4.2.1、运作机制</h3><p>特点：</p>
<ul>
<li>异步的</li>
<li>迭代的</li>
<li>自我终止的</li>
<li>分布式的</li>
</ul>
<p>&emsp;&emsp;对于每个路由器，一旦其有了新的最短路径，它就会将这条最短路径发送给它的邻居。最短路径通过Bellman-Ford方程选出来：$d_x(y) = min_v\{c(x,v)+d_v(y)\}$。</p>
<p>&emsp;&emsp;伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Variable declare:</span><br><span class="line">    x can be any node in the router topology</span><br><span class="line">    N is the set of all the destination nodes</span><br><span class="line">    G is the graph of all router nodes</span><br><span class="line"></span><br><span class="line">Initialization of node x:</span><br><span class="line">    for y in x.destinations:    &#x2F;&#x2F; x.destinations &#x3D; N</span><br><span class="line">        &#x2F;&#x2F; 最开始x只知道到其直接相邻的节点间的距离</span><br><span class="line">        if y is a neighbor of x: </span><br><span class="line">            D(x-&gt;y) &#x3D; c(x,y)</span><br><span class="line">        else:</span><br><span class="line">            D(x-&gt;y) &#x3D; INF    </span><br><span class="line">    distance vector DV(x-&gt;x.destinations) &#x3D; &#123;D(x-&gt;y), y in x.destinations&#125;</span><br><span class="line">    for w in x.neighbors:</span><br><span class="line">        send DV to w</span><br><span class="line"></span><br><span class="line">Loop:</span><br><span class="line">    &#x2F;&#x2F; 等待自身周边链路状态发生改变或者其他路由器周边链路状态发生改变</span><br><span class="line">    wait:</span><br><span class="line">        do nothing</span><br><span class="line">    until:</span><br><span class="line">        one link from x to its neighbor change or</span><br><span class="line">        x receive a DV vector from its neighbors</span><br><span class="line">    &#x2F;&#x2F; 更新DV向量，如有改变则重新发送给所有邻居</span><br><span class="line">    for y in x.destinations:</span><br><span class="line">        for v in x.neighbors:   &#x2F;&#x2F; 只能靠邻居中转</span><br><span class="line">            D(x-&gt;y) &#x3D; min&#123;c(x,v)+D(v-&gt;y),D(x-&gt;y)&#125;</span><br><span class="line">    if D(x-&gt;y) is changed for any y in x.destinations:</span><br><span class="line">        distance vector DV(x-&gt;x.destinations) &#x3D; &#123;D(x-&gt;y), y in x.destinations&#125;</span><br><span class="line">        for w in x.neighbors:</span><br><span class="line">            send DV to w    </span><br><span class="line">Forever</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-2、例子"><a href="#4-2-2、例子" class="headerlink" title="4.2.2、例子"></a>4.2.2、例子</h3><blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Distance-vector_routing_protocol" target="_blank" rel="noopener">DV算法：wikipedia</a></li>
</ul>
</blockquote>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/DV例子.png" alt="DV例子"></p>
<h3 id="4-2-3、路由选择环路（routing-loop）-amp-无穷计数问题（counting-to-infinity）"><a href="#4-2-3、路由选择环路（routing-loop）-amp-无穷计数问题（counting-to-infinity）" class="headerlink" title="4.2.3、路由选择环路（routing-loop）&amp;无穷计数问题（counting-to-infinity）"></a>4.2.3、路由选择环路（routing-loop）&amp;无穷计数问题（counting-to-infinity）</h3><p>&emsp;&emsp;无穷计数问题是路由选择环路的极端情况（链路费用更改为一个较大的值 -&gt; 链路中断/链路费用无穷大）。路由选择环路问题发生在链路断开或者两个路由器同时发送更新消息时。</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/路由选择环路举例.png" alt="路由选择环路举例"></p>
<h3 id="4-2-4、解决路由选择环路问题的方法"><a href="#4-2-4、解决路由选择环路问题的方法" class="headerlink" title="4.2.4、解决路由选择环路问题的方法"></a>4.2.4、解决路由选择环路问题的方法</h3><ul>
<li>定义最大度量值：防止计数到无穷大。</li>
<li>触发更新：<ul>
<li>当得知网络拓扑结构发生改变时，不等待发送周期，而是立刻通告更新后的全部的路由表。</li>
<li>路由选择进程修改其路由选择表中的路由的度量值后，将发送一条选择更新，其中的度量值被设置为一个表明相应的网络不可达值。在RIP中，为无穷大，即16跳。触发更新将信息立刻告诉其他路由器。如果网络出现问题，所有受影响的路由器都将立刻进入抑制状态，而不是等待定时器到期。这种机制提高了汇聚速度，有助于防止环路。</li>
</ul>
</li>
<li>水平分割：路由器向外发送某网段路由信息后不再接收<font color="red">从反方向发送回来的同一网段的</font>路由更新消息。</li>
<li>路由毒化（毒性反转）：如果$z$通过$y$到达$x$，那么$z$向$y$发送$D_z(x)=\infty$。只要$z$经过路由器$y$到达$x$，$z$就会持续向$y$讲述这个善意的谎言。</li>
<li>抑制计时器：等待网络中其他路由器收敛，在该时间内不学习任何与该网络相关的路由信息（RIP默认为180s），在倒计时期间继续向其他路由器发送毒化信息。</li>
</ul>
<h2 id="4-3、比较LS算法与DV算法"><a href="#4-3、比较LS算法与DV算法" class="headerlink" title="4.3、比较LS算法与DV算法"></a>4.3、比较LS算法与DV算法</h2><p>&emsp;&emsp;<font color="red">总体理解：</font>在DV算法中，每个节点仅与它直接相连的邻居交谈，但它为其邻居提供了从它自己到网络中所有其他节点（它所知道的）的最低费用估计；在LS算法中，每个节点（经广播）与所有其他节点交谈，但它仅告诉它们与它直接相连链路的费用。</p>
<p>&emsp;&emsp;<font color="red">报文复杂性：</font>LS算法每次需要发送$O(|N||E|)$个的报文，每个报文都是一个图，大小为$O(N^2)$，而且只要路由器检测到链路发生改变就会发送报文。相比之下，DV算法只需要发送$O(N)$个报文，每个报文都是一个向量，大小为$O(N)$，而且只有当最短路径发生改变时路由器才会发送报文。</p>
<p>&emsp;&emsp;<font color="red">收敛速度：</font>DV算法收敛速度较慢，且会遇到路由选择环路与无穷计数问题。</p>
<p>&emsp;&emsp;<font color="red">健壮性：</font>LS算法比DV算法更加健壮一些。</p>
<h1 id="5、层次路由选择"><a href="#5、层次路由选择" class="headerlink" title="5、层次路由选择"></a>5、层次路由选择</h1><h2 id="5-1、基本了解"><a href="#5-1、基本了解" class="headerlink" title="5.1、基本了解"></a>5.1、基本了解</h2><h3 id="5-1-1、原因"><a href="#5-1-1、原因" class="headerlink" title="5.1.1、原因"></a>5.1.1、原因</h3><p>&emsp;&emsp;采用层次路由选择的原因是规模与管理责任的问题。规模过于大的网络中单纯使用DV算法或LS算法开销将高的不可实现。另外有些组织可能希望按照自己的意愿去管理自己的网络，这也是使用层次路由选择的一个原因。</p>
<p>&emsp;&emsp;层次路由选择不追求全局最优，而是通过追求局部最优来最终取得不错的效果，这也是理想与实际的妥协。</p>
<h3 id="5-1-2、举例"><a href="#5-1-2、举例" class="headerlink" title="5.1.2、举例"></a>5.1.2、举例</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/层次路由.png" alt="层次路由"></p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/层次路由路由表举例.png" alt="层次路由路由表举例"></p>
<ul>
<li>We can also use three- or four-level hierarchical routing. In three-level hierarchical routing, the network is classified into a number of clusters. Each cluster is made up of a number of regions, and each region contains a number or routers. </li>
<li>Hierarchical routing is widely used in Internet routing and makes use of several routing protocols.<h3 id="5-1-3、热土豆协议"><a href="#5-1-3、热土豆协议" class="headerlink" title="5.1.3、热土豆协议"></a>5.1.3、热土豆协议</h3><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/热土豆协议.png" alt="热土豆协议"></li>
</ul>
<h2 id="5-2、路由选择信息协议（RIP）"><a href="#5-2、路由选择信息协议（RIP）" class="headerlink" title="5.2、路由选择信息协议（RIP）"></a>5.2、路由选择信息协议（RIP）</h2><p>&emsp;&emsp;RIP协议，AS内部路由选择协议/内部网关协议（IGP），基于DV算法，适用于小型同类网络，通过UDP交换路由信息，是基于UDP 520端口的<font color="red">应用层协议</font>，每隔30s向外发送一次更新报文。</p>
<p>&emsp;&emsp;由于RIP是距离矢量路由算法，需要放置“路由环路”的问题。RIP防止路由环路的方法有下面几种：</p>
<ul>
<li>水平分割</li>
<li>路由毒化（毒性反转）</li>
<li>抑制计时器</li>
</ul>
<p>&emsp;&emsp;其余注意点：</p>
<ul>
<li>RIP协议的一条路径的最大费用被限制为15（最多15跳），因此RIP的使用限制在网络直径不超过15跳的自治系统内。</li>
<li>在RIP中，路由选择更新信息在邻居之间通过使用一种RIP响应报文来交换，大约每30秒相互交换一次。响应报文又称为RIP通告。</li>
<li>如果一台路由器</li>
</ul>
<p>&emsp;&emsp;在Unix系统中，一个称为routed的进程执行RIP，用来维护路由选择信息并与相邻路由器中的routed进程交换报文。RIP是被当作一个应用层进程来实现的（是一个能操作Unix内核中的转发表的特殊进城）。</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/routed进程.png" alt="routed进程"></p>
<h2 id="5-3、开放最短路优先（OSPF）"><a href="#5-3、开放最短路优先（OSPF）" class="headerlink" title="5.3、开放最短路优先（OSPF）"></a>5.3、开放最短路优先（OSPF）</h2><blockquote>
<p>OSPF协议，AS内部路由选择协议/内部网关协议（IGP），基于LS算法</p>
</blockquote>
<ul>
<li>一般而言，OSPF在小规模的网络中收敛时间可达十多秒钟</li>
<li>算法本身没有环路问题</li>
<li>允许自治系统的网络被划分成区域管理，从而减少了占用的网络带宽（理想与实际的进一步妥协）</li>
<li>支持组播地址（对所有DR/BDR路由器的组播地址为224.0.0.6，对所有的非DR/BDR路由器的组播地址为224.0.0.5）。OSPF并不是周期性广播，节省了带宽资源。</li>
<li>OSPF的核心是使用一个洪泛链路状态信息的链路状态协议和一个Dijkstra最低费用路径算法。</li>
</ul>
<p>OSPF的优点：</p>
<ul>
<li>安全</li>
<li>多条费用相同的路径</li>
<li>对单播和多播路由选择的综合支持</li>
<li>支持在单个路由选择域内的层次结构——按层次组织AS<ul>
<li>区域边界路由器（ABR，area border router）：An area border router (ABR) is a kind of router that is located near the border between one or more Open Shortest Path First (OSPF) areas. It is used to establish a connection between backbone networks and the OSPF areas. It is a member of both the main backbone network and the specific areas to which it connects, so it stores and maintains separate routing information or routing tables regarding the backbone and the topologies of the area to which it is connected.</li>
<li>在AS内部只有一个OSPF区域配置成主干区域，该主干包含了AS内的所有区域边界路由器，并且可能还包含了一些非边界路由器。主干区域的作用是为AS内其他区域之间的流量提供路由选择。</li>
<li>在AS内部的区域间的路由选择要求分组首先路由到一个区域边界路由器（区域内路由选择），再通过主干路由到位于目的区域的区域边界路由器，然后再路由到最终目的地。</li>
</ul>
</li>
</ul>
<p>The Difference between ABR,DR,BDR,ASBR</p>
<ul>
<li>Area Border Router (ABR) Connects two or more areas, DR,BDR都是ABR</li>
<li>The DR serves as a common point for all adjacencies on a multiaccess segment</li>
<li>The BDR also maintains adjacencies with all routers in case the DR fails</li>
<li>AS Boundary Router (ASBR) Connects to additional routing domains; typically located in the backbone</li>
</ul>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/OSPF多区域例子.png" alt="OSPF多区域例子"></p>
<p>DR，BDR：</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/DR&amp;BDR.png" alt="DR&amp;BDR"></p>
<h2 id="5-4、自治系统间路由选择（BGP，AS间路由选择协议）"><a href="#5-4、自治系统间路由选择（BGP，AS间路由选择协议）" class="headerlink" title="5.4、自治系统间路由选择（BGP，AS间路由选择协议）"></a>5.4、自治系统间路由选择（BGP，AS间路由选择协议）</h2><blockquote>
<p>&emsp;&emsp;BGP协议是因特网中绝对至关重要的协议，从本质上讲，正是这个协议将所有的东西粘合在一起了。在学习BGP时要运用整体思想（将一个AS看做一个整体），AS网段前缀之于BGP正如端系统之于OSPF/RIP。BGP协议既不属于LS协议，也不是DV协议，而是PV（path vector）协议。</p>
</blockquote>
<h3 id="5-4-1、PV协议"><a href="#5-4-1、PV协议" class="headerlink" title="5.4.1、PV协议"></a>5.4.1、PV协议</h3><p><b>1. What is a path vector protocol</b></p>
<p>&emsp;&emsp;It is different from the distance vector routing and link state routing. Each entry in the routing table contains the destination network, the <font color="red">next router（NEXT-HOP）</font> and the <font color="red">path（AS-PATH）</font> to reach the destination.</p>
<p><b>2. How to prevent routing loop</b></p>
<p>&emsp;&emsp;A path vector protocol is essentially a distance vector protocol that does not rely on the distance to destination to guarantee a loop-free path but instead relies on the analysis of the path itself.</p>
<p><b>3. How to updata the routing table</b></p>
<p>&emsp;&emsp;An update example: In this case, router A advertises reachability to the 10.1.1.0/24 network to router B. When router B receives this information, it adds itself to the path, and advertises it to router C. Router C adds itself to the path, and advertises to router D that the 10.1.1.0/24 network is reachable in this direction.</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/PV例子-1616674307155.png" alt="PV例子"></p>
<h3 id="5-4-2、BGP基本了解"><a href="#5-4-2、BGP基本了解" class="headerlink" title="5.4.2、BGP基本了解"></a>5.4.2、BGP基本了解</h3><ul>
<li>在任何AS中的网关路由器接收到eBGP学习到的前缀后，该网关路由器使用它的iBGP会话来向该AS中的其他路由器发布这些前缀。</li>
<li>在BGP中，一个自治系统由其全局唯一的自治系统号（ASN）所标识（但不是每个AS都有ASN的，比如<font color="red">Stub AS</font>）。</li>
<li>前缀的BGP属性<ul>
<li>在BGP中，目的地不是主机而是CDIR化的前缀，带有BGP属性的前缀称为一条<font color="red">路由</font></li>
<li>AS-PATH：当一个路由器发现其自身所处的AS被包括在该路径列表中，它将拒绝该通告。</li>
<li>NEXT-HOP：<ul>
<li>是一个开始某AS-PATH的网关路由器接口,路由器通过NEXT-HOP来配置它的转发表</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/NEXT-HOP解释.png" alt="NEXT-HOP解释"></li>
</ul>
</li>
</ul>
</li>
<li>输入策略<ul>
<li>AS之间更多考虑想走哪里，而不是哪条路性能最优</li>
<li>网关路由器接收到一台路由器的通告时，根据输入策略来决定是否接受或过滤该路由。</li>
</ul>
</li>
</ul>
<h3 id="5-4-3、BGP路由选择"><a href="#5-4-3、BGP路由选择" class="headerlink" title="5.4.3、BGP路由选择"></a>5.4.3、BGP路由选择</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/BGP路由选择.png" alt="BGP路由选择"></p>
<h3 id="5-4-4、路由选择策略"><a href="#5-4-4、路由选择策略" class="headerlink" title="5.4.4、路由选择策略"></a>5.4.4、路由选择策略</h3><p>&emsp;&emsp;<font color="red">ISP网络与客户网络的路由选择策略。</font> </p>
<ul>
<li>stub network：只作发送与接收，不作转发的AS<ul>
<li>AS通过向其邻居通告它没有通往除了自身以外的AS的路径来表明其是一个桩网络（stub network）</li>
</ul>
</li>
<li>multi-homed stub network：经由多个提供商连接到网络的剩余部分的AS</li>
</ul>
<h1 id="6、广播与多播"><a href="#6、广播与多播" class="headerlink" title="6、广播与多播"></a>6、广播与多播</h1><p>&emsp;&emsp;之前的内容都是单播（unicast routing）（即点对点）的路由选择协议。</p>
<p>&emsp;&emsp;广播路由（broadcast routing）选择协议是网络层提供的从一个源节点到网络中的所有其他节点交付分组的服务；多播路由（multicast routing）协议使单个源节点能够向其他网络节点的一个子集发送分组的副本。</p>
<h2 id="6-1、广播路由选择（broadcast-routing）"><a href="#6-1、广播路由选择（broadcast-routing）" class="headerlink" title="6.1、广播路由选择（broadcast routing）"></a>6.1、广播路由选择（broadcast routing）</h2><ul>
<li>N次单播<ul>
<li>效率低</li>
<li>广播的发送方需要知道所有网络中的接收方及其地址</li>
</ul>
</li>
<li>无控制洪泛（flooding）：存在广播风暴<ul>
<li>源节点向其所有邻居发送分组，然后网络中每一个路由节点接收到分组以后，都会向其邻居发送分组副本。</li>
<li>致命缺陷是<font color="red">如果网络中有环路则会产生广播风暴（无休止的复制转发分组）</font></li>
</ul>
</li>
<li>受控洪泛：避免了广播风暴，但是仍然存在冗余广播分组的传输<ul>
<li>序号受控洪泛<ul>
<li>每个节点维护它已经收到的、复制的、转发的源地址和每个广播分组的序号列表</li>
<li>收到一个广播分组时，根据该分组的源地址和序号以及维护的列表判定自己是否已经收到并转发过，如果收到并转发过，那么丢弃该分组。</li>
</ul>
</li>
<li>反向路径转发（RPF，reverse path forwarding）<ul>
<li>当分组到达时，如果该分组是沿着最短路径从源路由器到达该路由器的，那么该路由器接受分组并转发，反之则丢弃分组</li>
<li>利用了最小生成树存在且唯一的思想</li>
</ul>
</li>
</ul>
</li>
<li>生成树广播<ul>
<li>注意到<font color="red">一个连通的网络拓扑结构中有且仅有一个最小生成树</font>，与选择谁作为树的起始点无关，这是前提。</li>
<li>通过计算得到一个最小生成树拓扑结构，阻塞其中一些链路，这避免了广播风暴与冗余分组的问题。</li>
</ul>
</li>
</ul>
<h2 id="6-2、多播路由选择（multicast-routing）"><a href="#6-2、多播路由选择（multicast-routing）" class="headerlink" title="6.2、多播路由选择（multicast routing）"></a>6.2、多播路由选择（multicast routing）</h2><h3 id="6-2-1、IGMP（因特网组管理协议）"><a href="#6-2-1、IGMP（因特网组管理协议）" class="headerlink" title="6.2.1、IGMP（因特网组管理协议）"></a>6.2.1、IGMP（因特网组管理协议）</h3><p>&emsp;&emsp;IGMP使得多播路由器知道多播组成员信息。</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E7%BD%91%E7%BB%9C%E5%B1%82/IGMP作用.png" alt="IGMP作用"></p>
<p>IGMP运行的两个阶段</p>
<ul>
<li>第一阶段：当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到IGMP报文后，将组成员关系转发给因特网上的其他多播路由器。</li>
<li>第二阶段：因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。<ul>
<li>只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。</li>
<li>但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</li>
</ul>
</li>
</ul>
<p>注意点：</p>
<ul>
<li>IGMP并非在因特网范围内对所有多播组成员进行管理的协议</li>
<li>IGMP并不知道多播组有多少成员、也不知道这些成员分布在哪些网络上</li>
<li>IGMP是让连接在本地局域网上的多播路由器知道本局域网内是否有主机（其实是主机上的进程）参加或退出了多播组</li>
<li>多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。</li>
</ul>
<p>IGMP采取的一些具体措施：</p>
<ul>
<li>在主机和多播路由器之间的所有通信都是使用IP多播。</li>
<li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文。默认的询问速率是每125秒发送一次。</li>
<li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。</li>
<li>在IGMP的询问报文中有一个数值N，它指明一个最长响应时间（默认值为10秒）。当收到询问时，主机在0到N之间随机选择发送响应所需经过的时延。对应于最小时延的响应最先发送。</li>
<li>同一个组内的每一个主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。</li>
</ul>
<h3 id="6-2-2、多播路由选择协议"><a href="#6-2-2、多播路由选择协议" class="headerlink" title="6.2.2、多播路由选择协议"></a>6.2.2、多播路由选择协议</h3><ul>
<li>使用一棵组共享树</li>
<li>使用一棵基于源的树<ul>
<li>实践中使用反向路径转发（RPF，reverse path forwarding）实现</li>
<li>剪枝问题</li>
</ul>
</li>
</ul>
<h1 id="PS：参考阅读"><a href="#PS：参考阅读" class="headerlink" title="PS：参考阅读"></a>PS：参考阅读</h1><ul>
<li><a href="https://computer.howstuffworks.com/routing-algorithm.htm" target="_blank" rel="noopener">https://computer.howstuffworks.com/routing-algorithm.htm</a></li>
<li><a href="http://www.mathcs.emory.edu/~cheung/Courses/455/Syllabus/5a-routing/distance-vec1.html" target="_blank" rel="noopener">http://www.mathcs.emory.edu/~cheung/Courses/455/Syllabus/5a-routing/distance-vec1.html</a>  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/" itemprop="url">应用层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-25T20:26:17+08:00">
                2021-03-25
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="应用体系结构">1、应用体系结构</h1>
<h2 id="client-server结构">1.1、Client-Server结构</h2>
<ul>
<li>集群技术的应用</li>
</ul>
<h2 id="peer-to-peer结构">1.2、Peer-to-Peer结构</h2>
<p>应用举例： - 文件共享（BitTorrent） - 对等方协助下载器（迅雷） - 因特网电话（Skype） - IPTV（迅雷看看、PPstream）</p>
<p>P2P面临的主要挑战： - ISP友好 - 安全性 - 激励</p>
<h1 id="应用层原理">2、应用层原理</h1>
<h2 id="进程通信">2.1、进程通信</h2>
<p>IP地址+端口</p>
<h2 id="运输服务">2.2、运输服务</h2>
<h3 id="四项服务">2.2.1、四项服务</h3>
<ul>
<li>可靠数据传输</li>
<li><font color="blue">吞吐量</font></li>
<li><font color="blue">定时</font></li>
<li>安全性</li>
</ul>
<h3 id="因特网提供的运输服务">2.2.2、因特网提供的运输服务</h3>
<ul>
<li>TCP
<ul>
<li>可靠数据传输</li>
<li>安全（SSL）</li>
</ul></li>
<li>UDP
<ul>
<li>哪一项也不能保证</li>
</ul></li>
</ul>
<h2 id="应用层协议通信规范">2.3、应用层协议（通信规范）</h2>
<p>应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p>
<p>应用层协议定义了如下内容： - 交换的报文类型 - 各种报文类型的语法 - 字段的语义 - 一个进程何时以及如何发送报文、对报文进行响应的规则</p>
<p>应用层协议是网络应用的一部分，要能够正确区分二者。</p>
<h2 id="重要的应用层协议">2.4、重要的应用层协议</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">应用</th>
<th style="text-align: left;">协议</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Web</td>
<td style="text-align: left;">HTTP</td>
</tr>
<tr class="even">
<td style="text-align: left;">文件传输</td>
<td style="text-align: left;">FTP</td>
</tr>
<tr class="odd">
<td style="text-align: left;">电子邮件</td>
<td style="text-align: left;">SMTP、POP3、IMAP</td>
</tr>
<tr class="even">
<td style="text-align: left;">域名解析</td>
<td style="text-align: left;">DNS</td>
</tr>
</tbody>
</table>
<h1 id="cs-webhttp">3、CS-Web：HTTP</h1>
<h2 id="web基础">3.1、Web基础</h2>
<p>Web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。</p>
<p>从个人理解角度而言，我将web与PC作了一下对比，发现了如下异同之处： - 资源管理器 vs 统一资源定位符（URL） - 本机安装的软件 vs web上的软件（SaaS） - 本机操作系统 vs 分布式系统</p>
<p>web基本组成： - web客户端：典型例子是浏览器 - web服务器 - web页面 - HTML基本文件 - 对象</p>
<h2 id="http协议">3.2、HTTP协议</h2>
<p>HTTP（HyperText Transfer Protocol），超文本传输协议，是Web的核心，是一种建立在TCP传输之上的应用层协议。 ### 3.2.1、HTTP协议的特点 - 简单快速 - 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。 - 由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 - 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 - 默认为非持续连接：一次连接传输一个对象 - 支持持续连接 - 是一种无状态协议 - 默认端口号为80</p>
<h3 id="非持续连接与持续连接">3.2.2、非持续连接与持续连接</h3>
<p><b>TCP相关内容</b></p>
<p>TCP的三次握手建立连接与四次挥手断开连接过程如下： <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/三次握手.png"><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/四次挥手.png"></p>
<ol type="1">
<li><b>非持续连接</b></li>
</ol>
每一个对象经受两倍RTT的交付时延，传输N的对象所用时间为<span class="math inline">\(2N*RTT+\sum\limits_{i=1}^{N}{t_i}\)</span>，其中<span class="math inline">\(t_i\)</span>是传输第<span class="math inline">\(i\)</span>个文件所用的时间。
<pre class="mermaid">sequenceDiagram
    participant client
    participant server
    loop SCSO
        client->>+server:在80端口发起一个到server的TCP连接（step1）
        server->>-client:server作出回应（step2）
        client->>+server:发送请求报文，该报文包含URL（step3：结合了TCP的client确认步骤）
        server->>-client:server封装对象并发送
        client->>client:client的TCP确认完整接收响应报文，然后关闭连接
        server->>server:server的TCP确认成功发送响应报文，然后关闭连接
    end</pre>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/非持续连接.png"></p>
<ol start="2" type="1">
<li><p><b>持续连接</b></p>
<pre class="mermaid">sequenceDiagram
 participant client
 participant server
 client->>+server:在80端口发起一个到server的TCP连接（step1）
 server->>-client:server作出回应（step2）
 loop SCMO
     client->>+server:发送请求报文，该报文包含URL（只有循环的第一次有TCP的client确认）
     server->>-client:server封装对象并发送
 end
 client->>client:client的TCP确认完整接收全部响应报文，然后关闭连接
 server->>server:server的TCP确认成功发送全部响应报文，然后关闭连接</pre>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/持续连接.png"></p></li>
<li><p><b>带流水的持续连接</b> <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/带流水的持续连接.png"></p></li>
</ol>
<h3 id="http请求报文">3.2.3、HTTP请求报文</h3>
<p><b>基本格式</b> <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/请求报文格式.png"></p>
<p>方法有如下几种： - GET：向服务器请求一个对象 - POST：用户请求一个web页面，例如用搜索引擎搜索 - HEAD：asks server to leave requested object out of response - PUT：向web服务器上传对象 - DELETE：删除web服务器上的对象</p>
<p>首部行基本内容： - Host：目的主机地址 - Connection：连接类型（close/keep-alive） - User-agent：用户代理，即向服务器发送请求的浏览器类型（如Chrome） - Accept-language：表示用户想得到的对象的语言版本</p>
<p><b>请求报文举例（GET）</b> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1\r\n    # 1.请求行</span><br><span class="line">Host: www.baidu.com\r\n         # 2.首部行</span><br><span class="line">Connection: close\r\n           # 2.首部行</span><br><span class="line">User-agent: chrome\r\n          # 2.首部行</span><br><span class="line">Accept-language: fr\r\n         # 2.首部行</span><br><span class="line">\r\n                            # 3.空行</span><br><span class="line">......data......                # 4.实体主体</span><br></pre></td></tr></table></figure></p>
<h3 id="http响应报文">3.2.4、HTTP响应报文</h3>
<p><b>基本格式</b> <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/响应报文格式.png"></p>
<p>状态码有如下几种： - 200：OK - 301：Moved Permanently - 400: Bad Request - 404：Not Found - 505：HTTP Version Not Supported</p>
<p>首部行有如下几种： - Connection：指示发送完报文后是否关闭连接 - Date：服务器产生并发送该响应报文的日期和时间 - Server：产生报文的服务器类型 - Last-Modified：最后修改日期，对于网络缓存服务器上的对象比较重要 - Content-Length：被发送对象的字节数 - Content-Type：表示发送的文件类型</p>
<p><b>响应报文举例（OK）</b> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK\r\n</span><br><span class="line">Connection: close\r\n</span><br><span class="line">Date: Tue, 09 Aug 2011 15:44:04 GMT\r\n</span><br><span class="line">Server: Apache&#x2F;2.2.2(CentOS)\r\n</span><br><span class="line">Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT</span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">(data data data data data ...)</span><br></pre></td></tr></table></figure></p>
<h3 id="使用telnet实践http协议">3.2.5、使用telnet实践HTTP协议</h3>
<p>操作顺序： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">win+r: cmd</span><br><span class="line">telnet www.baidu.com 80</span><br><span class="line">ctrl+]</span><br><span class="line">回车</span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">连续两次回车</span><br></pre></td></tr></table></figure> 获得如下响应报文： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 Found</span><br><span class="line">Location: https:&#x2F;&#x2F;www.baidu.com&#x2F;error.html</span><br><span class="line">Server: bfe</span><br><span class="line">Date: Sat, 09 Jun 2018 03:04:12 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure></p>
<h2 id="web优化cookie">3.3、Web优化：cookie</h2>
<p>由于HTTP是无状态协议，所以用户每一次访问站点都是全新的状态，这带来许多不便之处，例如购物车的维护。还有某些需要用户密码进行登录的网站，通过cookie可以免去每次都要进行的登陆操作。</p>
<p>不过cookie的使用也存在争议，因为他们被认为是对用户隐私的一种侵害。web站点通过cookie可以知道许多关于用户的信息，并可能将这些消息卖给第三方。</p>
<p>带有cookie的网站其HTTP协议访问过程如下： <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/cookie访问.png"></p>
<h2 id="web优化web-cacheproxy-serer">3.4、Web优化：web cache/proxy serer</h2>
<h3 id="原理">3.4.1、原理</h3>
<p>web缓存器又叫代理服务器，其既是客户又是服务器。 <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/web缓存器.png"></p>
<p>web缓存器可以与计算机组成中的cache做一下类比，二者原理是相似的： cache|web缓存 :-|:- cache命中|web缓存命中，HTTP请求的对象由代理服务器分发 cache缺失|web缓存缺失，HTTP请求的对象首先由代理服务器向初始服务器请求，然后再分发给客户 cache失效|条件GET发现目标已失效，代理服务器向初始服务器请求目标对象</p>
<h3 id="使用代理服务器的优点">3.4.2、使用代理服务器的优点</h3>
<ol type="1">
<li>可以大大减少对客户请求的响应时间（特别是当客户与初始服务器之间的瓶颈带宽远低于客户与代理服务器之间的瓶颈带宽时）。<img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/代理瓶颈.png"></li>
<li>能够大大减少一个机构的接入链路到因特网的通信量，通过减少通信量降低带宽需求，从而降低了费用。</li>
<li>web缓存器能够从整体上大大减低因特网上的web流量，从而改善了所有应用的性能。</li>
</ol>
<h3 id="条件get方法">3.4.3、条件GET方法</h3>
<p>代理服务器定期向初始服务器发送条件GET请求报文，请求报文示例如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: www.baidu.com\r\n</span><br><span class="line">If-Modified-Since: Wed, 7 Sep 2011 09:23:24\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure> 对应的响应报文示例如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 304 Not Modified\r\n</span><br><span class="line">Date: Sat, 15 Oct 2011 15:39:29\r\n</span><br><span class="line">Server: Apache&#x2F;1.3.0 (Unix)\r\n</span><br><span class="line">\r\n</span><br><span class="line">(empty entity body)</span><br></pre></td></tr></table></figure> # 4、CS-文件传输：FTP ## 4.1、连接 FTP使用两个并行的TCP连接来传输文件，一个是控制连接，一个是数据连接。其中控制连接是持续连接，数据连接是非持续连接。FTP是一个有状态的协议。 <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/ftp连接.png"></p>
<p>由于FTP使用独立的控制连接来传输控制信息（而HTTP的控制信息与数据是放在一起的），所以称FTP是带外（out-of-band）发送控制信息的，称HTTP是带内（in-band）发送控制信息的。</p>
<h2 id="命令与回答">4.2、命令与回答</h2>
<ul>
<li>命令
<ul>
<li>USER：向服务器发送用户标识</li>
<li>PASS：用于向服务器发送口令（密码）</li>
<li>LIST：请求获得远程主机当前目录下的的文件列表（建立新的数据连接发送）</li>
<li>RETR filename：检索（即get）远程主机当前目录下的目标文件</li>
<li>STOR：在远程主机当前目录下存放（即put）文件</li>
</ul></li>
<li>回答
<ul>
<li>331：Username OK, Password required（用户名OK，需要口令）</li>
<li>125：Data connection already open; transfer starting（数据连接已打开，开始传送）</li>
<li>425：Cant't open data connection（无法打开数据连接）</li>
<li>452：Error writing file（写文件差错）</li>
</ul></li>
</ul>
<h1 id="cs-电子邮件smtppop3imap">5、CS-电子邮件：SMTP、POP3、IMAP</h1>
<h2 id="电子邮件基础">5.1、电子邮件基础</h2>
<h3 id="地址userdomain_name">5.1.1、地址（USER@domain_name）</h3>
<ul>
<li>第一部分“USER”代表用户信箱的账号，对于同一个邮件接收服务器来说，这个账号必须是唯一的；</li>
<li>第二部分“@”是分隔符；</li>
<li>第三部分是用户信箱的邮件接收服务器域名，用以标志其所在的位置（通过DNS可获取其IP地址）。 ### 5.1.2、总体结构 电子邮箱系统主要有以下三个组件：</li>
<li>用户代理
<ul>
<li>用户代理 UA 就是用户与电子邮件系统的接口，是电子邮件客户端软件，例如outlook。</li>
<li>用户代理的功能：撰写、显示、处理和通信。</li>
<li>允许用户阅读、回复、转发、保存和撰写报文</li>
</ul></li>
<li>邮件服务器
<ul>
<li>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。</li>
<li>邮件服务器按照客户服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议。</li>
<li>种类
<ul>
<li>SMTP服务器</li>
<li>POP3/IMAP服务器</li>
</ul></li>
</ul></li>
<li>邮件传输协议
<ul>
<li>发送邮件的协议：SMTP</li>
<li>读取邮件的协议：POP3和IMAP <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/电子邮件系统结构.png"></li>
</ul></li>
</ul>
<h3 id="发送与接收电子邮件基本流程">5.1.3、发送与接收电子邮件基本流程</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">digraph pro&#123;</span><br><span class="line">    node[shape&#x3D;rect]</span><br><span class="line">    a[label&#x3D;&quot;发件人调用PC中的用户代理撰写和编辑要发送的邮件。&quot;]</span><br><span class="line">    b[label&#x3D;&quot;发件人的用户代理把邮件用SMTP协议发给发送方邮件服务器&quot;]</span><br><span class="line">    c[label&#x3D;&quot;SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送&quot;]</span><br><span class="line">    d[label&#x3D;&quot;发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP\n服务器建立TCP连接，然后就把邮件缓存队列中的邮件依次发送出去。&quot;]</span><br><span class="line">    e[label&#x3D;&quot;运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，\n把邮件放入收件人的用户邮箱中，等待收件人进行读取&quot;]</span><br><span class="line">    f[label&#x3D;&quot;收件人在打算收信时，就运行PC机中的用户代理，使用POP3\n（或IMAP）协议读取发送给自己的邮件&quot;]</span><br><span class="line">    a -&gt; b</span><br><span class="line">    b -&gt; c</span><br><span class="line">    c -&gt; d</span><br><span class="line">    d -&gt; e</span><br><span class="line">    e -&gt; f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单邮件传输协议smtp">5.2、简单邮件传输协议（SMTP）</h2>
<h3 id="基本了解">5.2.1、基本了解</h3>
<p>特点： - 采用持续连接的TCP，端口号为25 - 传输的信息必须是7位ASCII编码 - 连接在发送主机的SMTP客户和接收主机的SMTP服务器之间直接建立 - SMTP 规定了 14 条命令和 21 种应答信息。每条命令用 4 个字母组成，而每一种应答信息一般只有一行信息，由一个 3 位数字的代码开始，后面附上（也可不附上）很简单的文字说明。 - HTTP把每个对象封装到一个HTTP响应报文中；而SMTP将所有报文对象放在一个报文中。</p>
<p>三个阶段： - 连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。 - 邮件传送 - 连接释放：邮件发送完毕后，SMTP应释放TCP连接.</p>
<h3 id="命令">5.2.2、命令</h3>
<ul>
<li>HELO</li>
<li>MAIL FROM</li>
<li>RCPT TO</li>
<li>DATA</li>
<li>.</li>
<li>QUIT ### 5.2.3、响应</li>
<li>220</li>
<li>250</li>
<li>354</li>
<li>221 ### 5.2.4、邮件报文格式 典型的报文首部： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">From: alice@crepes.fr</span><br><span class="line">To: bob@hamburger.edu</span><br><span class="line">Subject: Searching for the meaning of life.</span><br></pre></td></tr></table></figure> ### 5.2.5、MIME：通用因特网邮件扩充 SMTP有以下缺点：</li>
<li>SMTP 不能传送可执行文件或其他的二进制对象。</li>
<li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带重音符号的法文或德文）就无法传送。</li>
<li>SMTP 服务器会拒绝超过一定长度的邮件。</li>
<li>某些 SMTP 的实现并没有完全按照[RFC 821]的 SMTP 标准。</li>
</ul>
<p>MIME 并没有改动 SMTP 或取代它。MIME 的意图是继续使用目前的[RFC 822]格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。 <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/MIME.png"></p>
<h3 id="使用telnet实验smtp协议">5.2.6、使用telnet实验SMTP协议</h3>
<p><a href="https://blog.csdn.net/zhangyulin54321/article/details/7599403)https://blog.csdn.net/zhangyulin54321/article/details/7599403" target="_blank" rel="noopener">??</a></p>
<h2 id="邮件访问协议">5.3、邮件访问协议</h2>
<h3 id="pop3">5.3.1、POP3</h3>
<h3 id="imap">5.3.2、IMAP</h3>
<p>IMAP是一个联机协议。当用户PC机上的IMAP客户程序打开IMAP服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。</p>
<p>优缺点： - IMAP最大的好处就是用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。 - IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像附件（此文件可能很大）的邮件。为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很长的附件。 - IMAP 的缺点是如果用户没有将邮件复制到自己的 PC 上，则邮件一直是存放在 IMAP 服务器上。因此用户需要经常与 IMAP 服务器建立连接。</p>
<h3 id="基于web的电子邮件">5.3.3、基于Web的电子邮件</h3>
<p>使用SMTP+HTTP而不是SMTP+POP3/IMAP。 <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/基于因特网的电子邮件.png"></p>
<h1 id="cs-域名解析dnsdomain-name-server">6、CS-域名解析：DNS（Domain Name Server）</h1>
<h2 id="域名">6.1、域名</h2>
<h3 id="为什么要有域名">6.1.1、为什么要有域名</h3>
<ul>
<li>域名只是个逻辑概念，并不代表计算机所在的物理地点。</li>
<li>变长的域名和使用有助记忆的字符串，是为了便于人来使用。而 IP 地址是定长的 32 位二进制数字则非常便于机器进行处理。</li>
</ul>
<h3 id="因特网的域名结构">6.1.2、因特网的域名结构</h3>
<ul>
<li>因特网采用了层次树状结构的命名方法。</li>
<li>任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。</li>
<li>域名的结构由标号序列组成，各标号之间用点隔开： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">digraph a&#123;</span><br><span class="line">    node[shape&#x3D;rect,style&#x3D;filled,fillcolor&#x3D;lemonchiffon]</span><br><span class="line">    a[label&#x3D;&quot;… .三级域名.二级域名.顶级域名&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 顶级域名有：</li>
<li>国家顶级域名</li>
<li>通用顶级域名</li>
<li>基础结构域名：arpa</li>
</ul>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/域名结构.png"></p>
<h2 id="域名服务器">6.2、域名服务器</h2>
<h3 id="服务器种类">6.2.1、服务器种类</h3>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/域名区与域.png"> <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/服务器层级.png"></p>
<ul>
<li>根域名服务器
<ul>
<li>根域名服务器是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。</li>
<li>不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。</li>
<li>在因特网上共有13个不同IP地址的根域名服务器（是13套装置而不是13台机器，例如根域名服务器f有49台机器分布在世界各地），它们的名字是用一个英文字母命名，从a 一直到 m（前13 个字母）。</li>
</ul></li>
<li>顶级域名服务器
<ul>
<li>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。</li>
<li>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</li>
</ul></li>
<li>权限域名服务器
<ul>
<li>负责一个区的域名服务器。</li>
<li>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</li>
</ul></li>
<li>本地域名服务器
<ul>
<li>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</li>
<li>每一个因特网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，</li>
<li>这种域名服务器有时也称为默认域名服务器。</li>
</ul></li>
<li>辅助域名服务器
<ul>
<li>DNS 域名服务器都把数据复制到几个域名服务器来保存，其中的一个是主域名服务器，其他的是辅助域名服务器。</li>
<li>当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。</li>
<li>主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。</li>
</ul></li>
</ul>
<h3 id="提供的服务">6.2.2、提供的服务</h3>
<ul>
<li>主机名到IP地址的转换</li>
<li>主机别名</li>
<li>邮件服务器别名</li>
<li>负载均衡：有点像集群</li>
</ul>
<h2 id="域名查询过程">6.3、域名查询过程</h2>
<h3 id="迭代查询">6.3.1、迭代查询</h3>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/DNS迭代查询.png"></p>
<h3 id="递归查询比较少用">6.3.2、递归查询（比较少用）</h3>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/DNS递归查询.png"></p>
<h3 id="dns优化dns缓存">6.3.3、DNS优化：DNS缓存</h3>
<ul>
<li>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。可大大减轻根域名服务器的负荷，使因特网上的 DNS 查询请求和回答报文的数量大为减少。</li>
<li>为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（例如，每个项目只存放两天）。</li>
<li>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。</li>
</ul>
<h2 id="dns协议">6.4、DNS协议</h2>
<h3 id="资源记录rr">6.4.1、资源记录（RR）</h3>
<p>共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record），RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记录。</p>
<p>资源记录是一个包含了下列4个字段的4元组：（Name，Value，Type，TTL） - Type=A - Name表示主机名，Value表示该主机名对应的IP地址 - 例如：<code>（relay1.bar.foo.com，145.37.93.126，A，the value of TTL）</code> - Type=NS - Name表示一个域，Value表示一个知道如何获得该域中主机IP地址的权威DNS服务器的主机名 - 例如：<code>（foo.com，dns.foo.com，NS，the value of TTL）</code> - Type=CNAME - Name表示主机别名，Value表示其对应的规范主机名 - 例如：<code>（foo.com，relay1.bar.foo.com，CNAME，the value of TTL）</code> - Type=MX - Name表示邮件服务器别名，Value表示其对应的规范主机名 - 例如：<code>（foo.com，mail.bar.foo.com，MX，the value of TTL）</code></p>
<h3 id="dns报文">6.4.2、DNS报文</h3>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/DNS报文格式.png"></p>
<h3 id="在dns数据库中插入记录">6.4.3、在DNS数据库中插入记录</h3>
<blockquote>
<p>注册登记机构：是一个商业实体，它验证域名的唯一性，将该域名输入DNS数据库，对提供的服务收取少量费用。</p>
</blockquote>
<blockquote>
<p>因特网名字和地址分配机构（ICANN）：向各种注册登记机构授权。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">digraph ex&#123;</span><br><span class="line">    splines &#x3D; line</span><br><span class="line">    rankdir &#x3D; TB</span><br><span class="line">    node[shape&#x3D;rect]</span><br><span class="line">    domin[label&#x3D;&quot;networkutopia.com&quot;]</span><br><span class="line">    domin -&gt; dnsserver[label&#x3D;&quot;插入RR条目（Web&amp;邮件服务器）\n(www.networkutopia.com, 212.212.212.5, A, TTL)\n(mail.networkutopia.com, 212.212.212.6, MX, TTL)&quot;]</span><br><span class="line"></span><br><span class="line">    dnsserver[label&#x3D;&quot;基本DNS服务器\ndns1.networkutopia.com\n212.212.212.1&quot;]</span><br><span class="line">    auxidnsserver[label&#x3D;&quot;辅助DNS服务器\ndns2.networkutopia.com\n212.212.212.2&quot;]</span><br><span class="line"></span><br><span class="line">    register[label&#x3D;&quot;这册登记机构&quot;]</span><br><span class="line"></span><br><span class="line">    &#123; dnsserver, auxidnsserver &#125; -&gt; register</span><br><span class="line">    register -&gt; DNS系统[label&#x3D;&quot;插入RR条目（查找路径&amp;查找结果）\n(networkutopia.com, dns1.networkutopia.com, NS, TTL)\n(dns1.networkutopia.com, 212.212.212.1, A, TTL)&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dns安全性">6.5、DNS安全性</h2>
<h3 id="针对dns服务的ddos攻击">6.5.1、针对DNS服务的DDoS攻击</h3>
<h3 id="利用dns向目标主机发起ddos攻击">6.5.2、利用DNS向目标主机发起DDoS攻击</h3>
<h1 id="p2p-文件分发">7、P2P-文件分发</h1>
<h2 id="性能比较">7.1、性能比较</h2>
<p>通过比较时间下界来比较CS结构与P2P结构的性能，并假定因特网核心具有足够的带宽（这意味着所有瓶颈都在网络接入链路）。</p>
<p>符号说明 符号|含义 :-|:- <span class="math inline">\(F\)</span>|分发的文件副本长度（bit数） <span class="math inline">\(N\)</span>|需要获得该文件的主机数 <span class="math inline">\(u_s\)</span>|upload server，服务器上载速率 <span class="math inline">\(d_s\)</span>|download server，服务器下载速率 <span class="math inline">\(d_1~d_N\)</span>|download i，主机i的下载速率 <span class="math inline">\(d_{min}\)</span>|N台主机的下载速率的最小值，即<span class="math inline">\(d_{min} = min\{d_1,d_2,\cdots,d_N\}\)</span></p>
<h3 id="cs结构分发n个文件副本所需时间d_cs">7.1.1、CS结构分发N个文件副本所需时间\(D_{cs}\)</h3>
<ol type="1">
<li><b>上载方：</b>服务器上传N个副本所需时间至少为<span class="math inline">\(\dfrac{NF}{u_s}\)</span>。</li>
<li><b>下载方：</b>所有下载方将副本下载完成所用时间至少为<span class="math inline">\(\dfrac{F}{d_{min}}\)</span></li>
</ol>
<p>由上述两点限制，可知CS结构分发N个文件副本所需时间</p>
<h3 id="p2p结构分发n个文件副本所需时间d_p2p">7.1.2、P2P结构分发N个文件副本所需时间<span class="math inline">\(D_{p2p}\)</span></h3>
<p>P2P结构性能的分析比较复杂，实际得到的时间下界实际上是经过多次放缩的结果。 1. <b>服务器上载</b>：服务器至少需要经其接入链路发送该文件的每个比特一次，故其时间下界为<span class="math inline">\(\dfrac{F}{u_s}\)</span>。 2. <b>总体上载</b>：<span class="math inline">\(\dfrac{NF}{u_s+\sum\limits_{i=1}^{N}{u_i}}\)</span> 3. <b>总体下载</b>：<span class="math inline">\(\dfrac{F}{d_{min}}\)</span></p>
<p>由上述三点限制，可知P2P结构分发N个文件副本所需时间</p>
<h3 id="实际性能比较">7.1.3、实际性能比较</h3>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/CS与P2P比较.png"></p>
<h2 id="bittorrent比特洪流使用tcp连接">7.2、BitTorrent（比特洪流，使用TCP连接）</h2>
<h3 id="基本概念">7.2.1、基本概念</h3>
<ul>
<li>追踪器（tracker）
<ul>
<li>每个洪流具有一个追踪器</li>
<li>当一个对等方加入洪流时，它向追踪器注册自己，并周期性的通知追踪器它仍在洪流中。</li>
</ul></li>
<li>临近对等方
<ul>
<li>最开始时由追踪器随机地从洪流中选取一个对等方子集作为新加入的peer（记为Jack）的临近对等方集。</li>
<li>随着时间流逝，Jack的临近对等方中可能有些会离开，其他对等方也有可能与Jack建立TCP连接而加入Jack的临近对等方集。</li>
</ul></li>
<li>块子集
<ul>
<li>在任何给定的时间，每个对等方将具有来自该洪流中要下载的文件F的块子集，并且不同的对等方具有不同的块子集。</li>
</ul></li>
<li>块列表
<ul>
<li>Jack周期性地询问每个临近对等方它们的块列表，如果Jack有M个对等方，那么Jack将获得M个块列表。通过块列表，Jack将对当前他还没有的块发出请求。</li>
</ul></li>
</ul>
<h3 id="请求与响应">7.2.2、请求与响应</h3>
<ul>
<li>发出请求：最稀缺优先
<ul>
<li>Jack在请求块时，优先选择在他的邻居中副本数量最少的块。</li>
<li>目标是均衡各个块在洪流中的副本数量。</li>
</ul></li>
<li>响应请求：一报还一报
<ul>
<li>对每个邻居持续地测量接收到比特的速率。</li>
<li>选取4个向自己传送数据速率最快的对等方（每隔10s重新计算速度并重新确定这四个对等方），这四者称为<font color="red">“疏通（unchoked）对等方”</font>。</li>
<li>每过30s，随机选择一个邻居Bob向其发送数据块，该邻居称为<font color="red">“试探对等方”</font>，如果Bob向Jack发送的数据足够快，那么Bob将会升级为疏通对等方，否则30s后Jack就不会向他发送数据了。</li>
<li>其余对等方称为<font color="red">“阻塞对等方”</font>，Jack将不会向他们发送数据。</li>
</ul></li>
</ul>
<h2 id="p2p文件分发的意义">7.3、P2P文件分发的意义</h2>
<p>个人认为P2P有多方面的意义： - 对服务器：解放了服务器的带宽占用，使得服务器能够同时处理多个大体积文件的下载请求，而无须占用大量带宽。 - 对下载方：增加了下载速度。</p>
<h2 id="问题与思考">7.4、问题与思考</h2>
<ul>
<li><font color="red">P2P一定要有服务器发送第一个副本吗？可以没有服务器吗？</font></li>
</ul>
<h1 id="p2p-数据库分布式散列表dht">8、P2P-数据库：分布式散列表DHT</h1>
<h2 id="基本了解-1">8.1、基本了解</h2>
<p>分布式散列表: - 表项为(key,value) = (resource_name,IP_address)。 - 整个表按照key值分割成几部分放置在不同的对等方上。</p>
<p>对等方编号与key值映射： - 为每个对等方分配一个 <span class="math inline">\([0,2^n-1]\)</span> 范围内的整数作标识符，n取某些固定的值。 - 未必一定要有<span class="math inline">\(2^n\)</span>个对等方，对等方的编号可以是不连续的。 - 利用散列函数将key映射为一个 <span class="math inline">\([0,2^n-1]\)</span> 范围内的整数。 - 分布式散列表的中心问题是定义为对等方分配键的规则（即根据key值决定选择哪一个对等方来存储key-value键值对）。</p>
<h2 id="添加新的键值对">8.2、添加新的键值对</h2>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/分布式散列表插入.png"></p>
<h3 id="id到ip的转换">8.2.1、ID到IP的转换</h3>
<ul>
<li>方法一：网状DHT。
<ul>
<li>要求每一个对等方都有一个包含所有(ID,IP)的表，每个对等方在本地能够直接根据ID获取对应的IP。</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/网状DHT.png"></li>
<li>占用资源多，对于大型系统完全不现实。</li>
</ul></li>
<li>方法二：环形DHT（环形覆盖网络）
<ul>
<li>每一个对等方知道其前任与后继的(ID,IP)对应关系。</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/环形DHT.png"></li>
<li>通过环形发送查询报文获取目的IP，平均每次查找要发送<span class="math inline">\(N/2\)</span>条报文（<span class="math inline">\(N\)</span>表示环形DHT中节点数量）。</li>
</ul></li>
<li>方法三：折中方案：有捷径的环形DHT
<ul>
<li>每个对等方关联多个其他对等方，即适当增加本地资源占用、减少发送报文数量。</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/有捷径的环形DHT.png"></li>
<li>重要的问题：<font color="red">“一个对等方应该有多少条捷径？那些对等方应该成为这些捷径邻居？”</font></li>
<li>研究表明DHT能够被设计为每个对等方的邻居数量以及每个请求平均发送的报文数量均为<span class="math inline">\(O(logN)\)</span>，其中<span class="math inline">\(N\)</span>为对等方的数量。这种设计给出了使用网状和环形覆盖网络拓扑的两种极端解决方案之间的一种满意折中方案。</li>
</ul></li>
</ul>
<h3 id="对等方扰动以环形覆盖网络为例">8.2.2、对等方扰动（以环形覆盖网络为例）</h3>
<p><b>1. 对等方退出：</b></p>
<p>让每个对等方能够联系其第一个和第二个后继（即知道他们的IP地址），每个对等方将会周期性地验证其两个后继是存活的（发送ping报文）。当某一对等方退出时，拓扑结构将对应发生改变。 <img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E5%BA%94%E7%94%A8%E5%B1%82/对等方扰动.png"></p>
<p>问题：<font color="red">如果两个后继同时推出呢？环形覆盖网络就发生了中断，这时候要怎么办？</font></p>
<p><b>2. 对等方加入：</b></p>
<p>假设新的对等方13要加入这个环形覆盖网，<font color="red">在加入时13仅知道对等方1的存在（即其IP地址）</font>，这时13将向1发送一个报文查询其前任与后继。1将该报文继续往后传递。当传到12时，12意识到自己是13的前任以及12的当前后继15为13的后继，这时候12将向13发送报文告知其前任与后继，这时候12、13、15都将作出对应修改。</p>
<h1 id="tcpudp套接字编程">9、TCP/UDP套接字编程</h1>
<p>这一部分内容属于“自己创造应用层协议”，是对前面所学知识的另一种简单实践。 ## 9.1、UDP套接字编程</p>
<h2 id="tcp套接字编程">9.2、TCP套接字编程</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/" itemprop="url">链路层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-25T20:26:17+08:00">
                2021-03-25
              </time>
            

            

            
          </span>

          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、链路层概述"><a href="#1、链路层概述" class="headerlink" title="1、链路层概述"></a>1、链路层概述</h1><h2 id="1-1、链路层提供的服务"><a href="#1-1、链路层提供的服务" class="headerlink" title="1.1、链路层提供的服务"></a>1.1、链路层提供的服务</h2><ul>
<li>成帧</li>
<li>链路接入<ul>
<li>媒体访问控制（MAC）协议：无论何时链路空闲，发送方都能发送数据帧</li>
</ul>
</li>
<li>可靠交付<ul>
<li>通常用于易于产生高差错率的链路，比如无线链路。其目的是<font color="red">本地纠正一个差错</font>而不是通过运输层或应用层协议迫使数据重传</li>
<li>对于低比特差错的链路，一般不提供这种服务</li>
</ul>
</li>
<li>差错检测和纠正</li>
</ul>
<h2 id="1-2、链路层在何处实现——网络适配器-网络接口卡"><a href="#1-2、链路层在何处实现——网络适配器-网络接口卡" class="headerlink" title="1.2、链路层在何处实现——网络适配器/网络接口卡"></a>1.2、链路层在何处实现——网络适配器/网络接口卡</h2><ul>
<li>核心是链路层控制器<ul>
<li>封装网络层数据报，（在首部设置差错检测比特）</li>
<li>抽取网络层数据报，（执行差错检测）</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/网络适配器.png" alt="网络适配器"></li>
</ul>
</li>
<li>越来越多的网络适配器被综合进主机的主板</li>
<li>链路层是硬件和软件的结合体，<font color="red">是协议栈中硬件与软件交接的地方</font></li>
</ul>
<h2 id="1-3、链路层的拓扑结构"><a href="#1-3、链路层的拓扑结构" class="headerlink" title="1.3、链路层的拓扑结构"></a>1.3、链路层的拓扑结构</h2><ul>
<li>（以前）总线拓扑：广播局域网</li>
<li>（以前）星型拓扑+集线器：广播局域网</li>
<li>（当今）星型拓扑+交换机：交换局域网<ul>
<li>采用存储转发分组交换</li>
<li>没有必要使用MAC协议</li>
</ul>
</li>
</ul>
<h1 id="2、差错监测和纠正技术"><a href="#2、差错监测和纠正技术" class="headerlink" title="2、差错监测和纠正技术"></a>2、差错监测和纠正技术</h1><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/差错检测与纠正.png" alt="差错检测与纠正"></p>
<h2 id="2-1、奇偶校验（使1的数量为偶数）"><a href="#2-1、奇偶校验（使1的数量为偶数）" class="headerlink" title="2.1、奇偶校验（使1的数量为偶数）"></a>2.1、奇偶校验（使1的数量为偶数）</h2><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/奇偶校验.png" alt="奇偶校验"></p>
<h2 id="2-2、检验和方法（传输层中用到的方法）"><a href="#2-2、检验和方法（传输层中用到的方法）" class="headerlink" title="2.2、检验和方法（传输层中用到的方法）"></a>2.2、检验和方法（传输层中用到的方法）</h2><p>&emsp;&emsp;运输层差错检测用软件实现，采用简单而快速如检验和方法的方案是很重要的。然而在链路层中的差错检测在网络适配器中使用专用的硬件实现，它能够快速执行更复杂的CRC操作。</p>
<h2 id="2-3、循环冗余检测（CRC）"><a href="#2-3、循环冗余检测（CRC）" class="headerlink" title="2.3、循环冗余检测（CRC）"></a>2.3、循环冗余检测（CRC）</h2><blockquote>
<p>循环冗余检测编码/CRC编码/多项式编码</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">data，数据比特</td>
</tr>
<tr>
<td style="text-align:left">R</td>
<td style="text-align:left">Remainder，余数，CRC比特</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td style="text-align:left">Generator，生成多项式，最高有效位必须是1</td>
</tr>
</tbody>
</table>
</div>
<p>$\%_2$|通过模2计算取余数，模2运算中加法不进位，减法不借位，加减相当于异或（$\oplus$）运算；<br>乘法和除法则不变。</p>
<ul>
<li>发送方<ul>
<li>$G$事先由双方协商选择</li>
<li>$R=(D&lt;&lt;(G.length-1))\%_2G$</li>
<li>$SendData = (D&lt;&lt;(G.length-1))+R$</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/CRC发送方.png" alt="CRC发送方"></li>
</ul>
</li>
<li>接收方<ul>
<li>$RecvData\%_2G=0$：未发生比特差错</li>
<li>$RecvData\%_2G\neq0$：发生比特差错</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/CRC接收方.png" alt="CRC接收方"></li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;国际标准已经定义了8/12/16/32比特生成多项式。每个CRC标准都能检测小于r+1比特的突发差错（即可以检测到连续的r比特或更少的差错）；在适当的假设下，长度大于r+1比特的突发差错以概率$1-0.5^r$被检测到；每个CRC标准也能检测到任何奇数个比特差错。</p>
<h1 id="3、多路访问链路和协议"><a href="#3、多路访问链路和协议" class="headerlink" title="3、多路访问链路和协议"></a>3、多路访问链路和协议</h1><h2 id="3-1、基本了解"><a href="#3-1、基本了解" class="headerlink" title="3.1、基本了解"></a>3.1、基本了解</h2><blockquote>
<ol>
<li>点对点链路：链路两端只有一个发送方和一个接收方</li>
<li>广播链路：多个发送节点和接受节点挂到同一个共享的链路（广播信道）上。</li>
<li>多路访问问题：如何协调多个发送和接收节点对一个共享广播信道的访问的问题。为解决该问题而设计的协议称为多路访问协议。</li>
<li>碰撞：多个节点同时传输帧，接收节点同时接收帧，碰撞帧的信号纠缠在一起，所有的帧都丢失了。</li>
</ol>
</blockquote>
<ul>
<li>多路访问协议种类<ul>
<li>信道划分协议</li>
<li>随机接入协议</li>
<li>轮流协议</li>
</ul>
</li>
<li>理想的多路访问协议（假设广播信道速率为$R\ bps$）<ul>
<li>当仅有一个结点有数据发送时,该结点具有$R\ bps$的吞吐量;<ul>
<li>随机接入协议</li>
<li>轮流协议（可能稍微低一些）</li>
</ul>
</li>
<li>当有M个结点要发送数据时,每个结点吞吐量为$R/M\ bps$的吞吐量（平均传输速率而不是瞬时传输速率）;<ul>
<li>轮流协议</li>
</ul>
</li>
<li>协议是分散的，这就是说不会因某主结点故障而使整个系统崩溃。</li>
<li>协议是简单的，使实现不昂贵。</li>
</ul>
</li>
</ul>
<h2 id="3-2、信道划分协议"><a href="#3-2、信道划分协议" class="headerlink" title="3.2、信道划分协议"></a>3.2、信道划分协议</h2><ul>
<li>时分多路复用TDM<ul>
<li>将一个时间帧划分成多个较小的时隙（slot），每个时隙应该能够发送一个数据帧</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/TDM.png" alt="TDM"></li>
<li>消除了碰撞并且十分公平，但是效率比较低（因为并不是每个时隙都有链路要发送数据帧的）</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/TDM例子.png" alt="TDM例子"></li>
</ul>
</li>
<li>频分多路复用FDM<ul>
<li>将$R\ bps$的链路分成N个较小的$R/N\ bps$的信道，这限制了单个信道发送的速率。</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/FDM.png" alt="FDM"></li>
<li>与TDM的优缺点是相似的</li>
</ul>
</li>
<li>码分多址CDMA<ul>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/CDMA例子.png" alt="CDMA例子"></li>
</ul>
</li>
</ul>
<h2 id="3-3、随机接入协议"><a href="#3-3、随机接入协议" class="headerlink" title="3.3、随机接入协议"></a>3.3、随机接入协议</h2><blockquote>
<p><font color="red">一个传输节点总是以信道的全部速率发送数据帧</font>，当遇到碰撞时，每个节点反复重新发送它的数据帧，直至该帧无碰撞地通过为止。不过每次碰撞以后并不是立即重发，而是随机等待一段时延之后再发。</p>
<h3 id="3-3-1、纯ALOHA"><a href="#3-3-1、纯ALOHA" class="headerlink" title="3.3.1、纯ALOHA"></a>3.3.1、纯ALOHA</h3><ul>
<li>当一个帧首次到达时，结点立即将该帧完整地传输到信道中<ul>
<li>如果发生碰撞，那么该结点在该碰撞帧传输后，以概率p重新传输。</li>
<li><font color="red">否则...</font></li>
</ul>
</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/aloha碰撞.png" alt="aloha碰撞"></li>
<li>当有N个活跃节点时，纯ALOHA的效率是$Np(1-p)^{2(N-1)}$。<ul>
<li>该协议的最大效率为$\dfrac{1}{2e}\approx$0.18。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-3-2、时隙ALOHA"><a href="#3-3-2、时隙ALOHA" class="headerlink" title="3.3.2、时隙ALOHA"></a>3.3.2、时隙ALOHA</h3><ul>
<li>当结点有一个新帧要发送时,它等到下一个时隙开始并在该时隙传输整个帧。<ul>
<li>如果没有碰撞,该结点成功地传输它的帧,从而不需要考虑重传该帧(如果该结点有新帧,它能够为传输准备一个新帧)。</li>
<li>如果有碰撞,该结点在时隙结東之前检测到这次碰撞。该结点以概率p在后续的每个时隙中重传它的帧,直到该帧被无碰撞地传输出去。</li>
</ul>
</li>
<li>当有N个活跃节点时，时隙ALOHA的效率是$Np(1-p)^{N-1}$。<ul>
<li>该协议的最大效率为$\dfrac{1}{e}\approx$0.37。</li>
</ul>
</li>
<li>时隙ALOHA要求所有的节点同步它们的传输。</li>
</ul>
<h3 id="3-3-3、载波侦听多路访问（CSMA，carrier-sensing-multi-access）"><a href="#3-3-3、载波侦听多路访问（CSMA，carrier-sensing-multi-access）" class="headerlink" title="3.3.3、载波侦听多路访问（CSMA，carrier sensing multi access）"></a>3.3.3、载波侦听多路访问（CSMA，carrier sensing multi access）</h3><ul>
<li>传输前先侦听链路状态<ul>
<li>如果有数据在传输：现在不传输，<font color="red">随机等待一段时间后再开始侦听链路状态</font></li>
<li>如果链路空闲：传输自己的数据帧</li>
</ul>
</li>
<li>冲突仍然可能发生<ul>
<li>两个链路同时侦听到链路当前空闲，开始传输数据帧</li>
<li><font color="red">当检测到碰撞以后节点仍然会传输完该碰撞帧</font>，传输完以后会先随机等待一段时间，然后再开始侦听链路状态</li>
</ul>
</li>
</ul>
<h3 id="3-3-4、具有碰撞检测的载波侦听多路访问（CSMA-CD）"><a href="#3-3-4、具有碰撞检测的载波侦听多路访问（CSMA-CD）" class="headerlink" title="3.3.4、具有碰撞检测的载波侦听多路访问（CSMA/CD）"></a>3.3.4、具有碰撞检测的载波侦听多路访问（CSMA/CD）</h3><p>&emsp;&emsp;相比于CSMA来讲，CSMA/CD的改进之处在于检测到碰撞以后节点将会立即停止数据帧的传输（即剩余部分不传了，这<font color="red">使得其他等待传输数据的节点/重传的等待时间减少</font>），然后随机等待一段时间，再开始侦听链路状态。</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/CSMA与CSMA+CD的对比.png" alt="CSMA与CSMA+CD的对比"></p>
<p>&emsp;&emsp;<font color="red">随机等待的时间如何选择？</font></p>
<p>通过使用二进制指数后退的方法进行选择：在结点经历了连续n次碰撞以后，随机等待的时间单元$t_{unit}\in N^+$将会从$[0,2^n-1],n\in[1,10]$中随机选取一个数字$K$作为其要等待的时间单元数。每一个时间单元是传输$512\ bit$的时间。也就是说，等待时间（如果用比特来衡量的话）将会是连续传输$512\cdot K\ bit$所需的时间。</p>
<p>&emsp;&emsp;<font color="red">CSMA/CD的效率评价？</font></p>
<blockquote>
<p>我们将CSMA/CD的效率（efficiency of CSMA/CD）定义为:当有大量的活跃结点,且每个结点有大量的帧要发送时,帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。</p>
</blockquote>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/CSMA-CD效率.png" alt="CSMA-CD效率"></p>
<p>&emsp;&emsp;CSMA/CD的性能比ALOHA更好，而且比较简单、便宜、并且是去中心化的。</p>
<h2 id="3-4、轮流协议"><a href="#3-4、轮流协议" class="headerlink" title="3.4、轮流协议"></a>3.4、轮流协议</h2><h3 id="3-4-1、（中心化的）轮询协议（polling-protocol）"><a href="#3-4-1、（中心化的）轮询协议（polling-protocol）" class="headerlink" title="3.4.1、（中心化的）轮询协议（polling protocol）"></a>3.4.1、（中心化的）轮询协议（polling protocol）</h3><p>&emsp;&emsp;有一个结点被指定为主节点（master node），主节点以循环的方式轮询其余节点。</p>
<ul>
<li>主节点向节点1发送一个报文，告诉它能够传输的帧的最大数量。</li>
<li>节点1发送结束（到达最大数量或者未到达最大数量），主节点侦听到链路空闲，以同样的方式告知节点2使之能够传输数据帧。</li>
<li>依照此过程循环进行。</li>
</ul>
<p>&emsp;&emsp;存在的缺点</p>
<ul>
<li>轮询占用额外的时间（额外报文&amp;最大传输数量）</li>
<li>主节点出现故障时，整个信道将会不可操作</li>
</ul>
<h3 id="3-4-2、（去中心化的）令牌传递协议（token-passing-protocol）"><a href="#3-4-2、（去中心化的）令牌传递协议（token-passing-protocol）" class="headerlink" title="3.4.2、（去中心化的）令牌传递协议（token-passing protocol）"></a>3.4.2、（去中心化的）令牌传递协议（token-passing protocol）</h3><p>&emsp;&emsp;没有主节点，一个被称为令牌（token）的小的特殊帧在节点之间按照特定的顺序进行传递（例如环形传递），拥有令牌的节点发送最大数目的帧数，然后将令牌传递给下一个节点。</p>
<p>&emsp;&emsp;优点是令牌是分散的，并且有很高的效率；缺点是一个节点的故障可能导致整个信道的崩溃。</p>
<h2 id="3-5、DOCSIS：用于电缆因特网接入的链路层协议"><a href="#3-5、DOCSIS：用于电缆因特网接入的链路层协议" class="headerlink" title="3.5、DOCSIS：用于电缆因特网接入的链路层协议"></a>3.5、DOCSIS：用于电缆因特网接入的链路层协议</h2><h1 id="4、交换局域网"><a href="#4、交换局域网" class="headerlink" title="4、交换局域网"></a>4、交换局域网</h1><h2 id="4-1、链路层地址"><a href="#4-1、链路层地址" class="headerlink" title="4.1、链路层地址"></a>4.1、链路层地址</h2><p>&emsp;&emsp;链路层地址有多种不同的叫法，如LAN地址、物理地址、MAC地址等，其中最为流行的是MAC地址。适配器的MAC地址被设计为永久的（不过现在通过软件也能修改，可能是假装修改？<font color="red">在后面的学习中，暂且认定MAC地址不可修改</font>）。MAC地址长度一般为48位，广播地址为FF-FF-FF-FF-FF-FF（即全1）。</p>
<p>&emsp;&emsp;MAC地址存在的意义是使网络体系结构中各层次成为极为独立的模块，让不同的层次拥有它们自己的寻址方案。</p>
<ul>
<li>如果网络适配器的地址直接用IP地址，那么适配器的地址将会不停地改变，无法方便地支持其他协议</li>
<li>如果网络适配器的地址不指定任何地址，所有的帧都交付给上层，由网络层来筛选的话，主机将被局域网上发送的每个帧中断。</li>
</ul>
<p>&emsp;&emsp;目前已经学到的有三种地址：</p>
<ul>
<li>主机名：DNS将主机名翻译成IP地址</li>
<li>IP地址：ARP将IP地址翻译成MAC地址</li>
<li>MAC地址：真正对应到物理设备（网络适配器/网卡）的地址</li>
</ul>
<h2 id="4-2、以太网"><a href="#4-2、以太网" class="headerlink" title="4.2、以太网"></a>4.2、以太网</h2><p>&emsp;&emsp;以太网对本地局域网联网的重要性就像因特网对全球联网所具有的地位那样。以太网提供的服务是<font color="red">无连接的</font>、<font color="red">不可靠的</font>。</p>
<h3 id="4-2-1、以太网帧结构"><a href="#4-2-1、以太网帧结构" class="headerlink" title="4.2.1、以太网帧结构"></a>4.2.1、以太网帧结构</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/以太网帧结构.png" alt="以太网帧结构"></p>
<ul>
<li>数据字段（45~1500字节）</li>
<li>目的MAC地址</li>
<li>源MAC地址</li>
<li><font color="red">类型字段</font>
  - 与网络层报文的协议字段、运输层报文段的端口号字段功能类似，都<font color="red">是一种多路分解与多路复用</font></li>
<li>CRC：检测是否传输过程中引入了差错</li>
<li>前同步码（8字节）<ul>
<li>适配器无法以精确的额定速率传输帧，实际速率相比于额定速率总会有一些“漂移”</li>
<li>时钟同步</li>
<li><a href="https://www.techwalla.com/articles/what-is-an-ethernet-preamble" target="_blank" rel="noopener">https://www.techwalla.com/articles/what-is-an-ethernet-preamble</a></li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/前同步码作用.png" alt="前同步码作用"></li>
</ul>
</li>
</ul>
<h3 id="4-2-2、以太网技术"><a href="#4-2-2、以太网技术" class="headerlink" title="4.2.2、以太网技术"></a>4.2.2、以太网技术</h3><h2 id="4-3、链路层交换机"><a href="#4-3、链路层交换机" class="headerlink" title="4.3、链路层交换机"></a>4.3、链路层交换机</h2><h3 id="4-3-1、基本了解"><a href="#4-3-1、基本了解" class="headerlink" title="4.3.1、基本了解"></a>4.3.1、基本了解</h3><p>&emsp;&emsp;交换机没有IP地址与MAC地址（除了特例），<font color="red">交换机输出接口设有缓存</font>用于解决帧到达速率超过帧转发速率的问题。</p>
<p>&emsp;&emsp;交换机的两个基本功能是过滤（filtering）与转发（forwarding），如果目标MAC地址在交换机表中不存在，那么交换机将会丢弃该帧，否则转发到对应端口。交换机表如下图所示：</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/交换机表示例.png" alt="交换机表示例"></p>
<h3 id="4-3-2、自学习"><a href="#4-3-2、自学习" class="headerlink" title="4.3.2、自学习"></a>4.3.2、自学习</h3><p>&emsp;&emsp;在开始时，交换机的交换机表显然是空的.交换机的一个优点就是其具有自学习的特性——交换机表的建立不需要管理员配置。学习过程如下：</p>
<ul>
<li>交换机表初始为空</li>
<li>对于在每个接口接收到的每个入帧，该交换机在其交换机表中存储：<ul>
<li>该帧的源MAC地址</li>
<li>该帧到达的接口</li>
<li>当前时间</li>
</ul>
</li>
<li>如果在一段时间后（称为老化期（aging time）），交换机没有接收到以该地址作为源地址的帧，那么就会在交换机表中删除这个表项。</li>
</ul>
<h3 id="4-3-3、链路层交换机的性质"><a href="#4-3-3、链路层交换机的性质" class="headerlink" title="4.3.3、链路层交换机的性质"></a>4.3.3、链路层交换机的性质</h3><ul>
<li>消除碰撞<ul>
<li>在使用交换机构成的局域网中，没有因碰撞而浪费的带宽<font color="red">（这是因为有缓存）</font>。</li>
<li>交换机的最大聚合带宽是该交换机的所有接口速率之和。</li>
</ul>
</li>
<li>异质的链路<ul>
<li>交换机将链路彼此隔离，因此局域网中的不同链路能够以不同的速率运行并且能够在不同的媒体上运行。</li>
<li>对于原有的设备与新设备的混用，交换机是理想的。</li>
</ul>
</li>
<li>管理<ul>
<li>更加易于网络的管理。</li>
</ul>
</li>
</ul>
<h3 id="4-3-4、安全问题"><a href="#4-3-4、安全问题" class="headerlink" title="4.3.4、安全问题"></a>4.3.4、安全问题</h3><p>&emsp;&emsp;交换机毒化与数据帧窃听。</p>
<h3 id="4-3-5、比较switch与router"><a href="#4-3-5、比较switch与router" class="headerlink" title="4.3.5、比较switch与router"></a>4.3.5、比较switch与router</h3><p>&emsp;&emsp;交换机与路由器<font color="red">本质上都是存储转发分组交换机</font>，区别在于路由器根据IP地址进行转发，而交换机根据MAC地址进行转发。另外，路由器因为有多条路由（环路）所以需要一个路由表来存储这些信息，转发表来存储具体如何转发的信息；而交换机不存在多个选择（没有环路），所以只需要一个转发表。</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/互联设备特色比较.png" alt="互联设备特色比较"></p>
<ul>
<li>交换机的优缺点<ul>
<li>优点<ul>
<li>即插即用</li>
<li>具有相对高的分组过滤和转发速率</li>
</ul>
</li>
<li>缺点<ul>
<li>交换网络的活跃拓扑限制为一棵生成树（这限制了交换网络的拓扑结构）。</li>
<li>一个大型的交换网络要求在主机和路由器中有较大的ARP表，这将生成可观的ARP流量和处理量</li>
<li>交换机对广播风暴并不提供任何保护措施，如果某主机发生故障并传输出没完没了的以太网广播帧，交换机将会转发这些帧，使得整个以太网崩溃。</li>
</ul>
</li>
</ul>
</li>
<li>路由器的优缺点<ul>
<li>优点<ul>
<li>因为网络寻址是层次化的（不像链路层寻址那样扁平化），所以即便当网络中存在冗余路径，分组通常也不会通过路由器循环。</li>
<li>网络拓扑结构可以更加丰富，不必限制为一棵生成树。</li>
</ul>
</li>
<li>缺点<ul>
<li>处理报文时间更长</li>
<li>不是即插即用的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-4、地址解析协议（ARP）"><a href="#4-4、地址解析协议（ARP）" class="headerlink" title="4.4、地址解析协议（ARP）"></a>4.4、地址解析协议（ARP）</h2><p><b>1. 一个类比</b></p>
<p>&emsp;&emsp;与操作系统内存管理来类比的话，可以将MAC地址看做是物理地址，将IP地址看做是逻辑地址。物理地址固定不动，逻辑地址灵活多变。通过在物理地址之上再加一层逻辑地址将使得整个网络（内存，如虚存）更加方便管理。ARP协议就是将“逻辑地址”翻译成“物理地址的过程”（类比OS中的页表）。</p>
<p><b>2. ARP的特点</b></p>
<ul>
<li>即插即用：一个ARP表是自动建立的，不需要系统管理员来配置</li>
<li>通常一个ARP的表项的过期时间为20分钟<ul>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/ARP表举例.png" alt="ARP表举例"></li>
</ul>
</li>
<li>查询ARP报文在广播帧中发送；响应ARP报文在一个标准帧中发送。</li>
<li>应当把ARP协议看做是跨越链路层和网络层边界两边的协议，不属于五层协议中的任何一层（现实世界协议就是这样复杂）。<ul>
<li>因为<font color="red">ARP报文中包含IP地址</font></li>
</ul>
</li>
<li>一个适配器对应一个ARP模块。</li>
</ul>
<h2 id="4-5、ARP-Switch表的工作过程"><a href="#4-5、ARP-Switch表的工作过程" class="headerlink" title="4.5、ARP+Switch表的工作过程"></a>4.5、ARP+Switch表的工作过程</h2><h3 id="4-5-1、子网内工作"><a href="#4-5-1、子网内工作" class="headerlink" title="4.5.1、子网内工作"></a>4.5.1、子网内工作</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/子网内拓扑.png" alt="子网内拓扑"></p>
<p>&emsp;&emsp;开始时，交换机中的交换机表都是空的，从初始化状态到主机C成功发送给主机I的流程如下：</p>
<ol>
<li>主机C希望发消息给主机I，但是C的ARP表中没有主机I的表项</li>
<li>主机C广播ARP查询报文（MAC_Src=C_MAC，MAC_Dest=FF-FF-FF-FF-FF-FF，IP_Src=C_IP，IP_Dest=I_IP）。</li>
<li>S1收到C发出的ARP广播报文，<font color="red">添加ARP表项(C_IP,C_MAC)并且添加交换机表项（C_MAC，对应端口号）</font>，然后转发到A，B，S4。</li>
<li>S4，S2，S3工作步骤与3中S1一致。</li>
<li>主机I收到该ARP广播报文，对比目的IP地址发现自己就是该ARP查询报文要查询的主机，发送ARP响应报文（MAC_Src=I_MAC，MAC_Dest=FC_MAC，IP_Src=I_IP，IP_Dest=C_IP）。</li>
<li>S3，S4，S1转发并<font color="red">添加I_IP的ARP表项以及I_MAC的交换机表项</font>，转发给C，C在其自身的ARP表中添加（I_IP，I_MAC）表项。</li>
<li>C的网卡查询自身ARP表，将（MAC_Src=C_MAC，MAC_Dest=I_MAC）封装到数据帧中，发送给S1</li>
<li><font color="red">S1读取帧首部信息，查询交换机表，根据(I_MAC，对应端口)进行转发，S4，S3同理。</font>最终S3将该数据帧转发给主机I，转发结束。</li>
</ol>
<h3 id="4-5-2、子网间工作"><a href="#4-5-2、子网间工作" class="headerlink" title="4.5.2、子网间工作"></a>4.5.2、子网间工作</h3><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/子网间拓扑.png" alt="子网间拓扑"></p>
<p>&emsp;&emsp;开始时，假设S1的ARP表与交换机表都是空的，路由器中有B的ARP表项和B所在网段的路由表项，交换机S2是有主机B的ARP表项和交换机表项的。从该状态到主机A成功发送网络层数据报给主机B的流程如下：</p>
<ol>
<li>主机A找不到主机B的ARP表项，发送ARP查询报文，经S1转发到达路由器的端口P1（同时S1记录A的ARP转换表项与交换机表项）。</li>
<li>路由器终止链路层广播，查路由表项，发现主机B对应端口P2，于是对该ARP查询报文作出响应，发送ARP响应报文，该报文经S1转发给A，S1学习到主机B的ARP表项与交换机表项，A学习到主机B的ARP表项。</li>
<li>A封装报文发送给S1，S1查交换机表然后转发给路由器，路由器查自己的ARP表将MAC_Src和MAC_Dest都替换掉，发给S2。</li>
<li>S2转发给主机B，转发结束。</li>
</ol>
<h2 id="4-9、虚拟局域网（vlan）"><a href="#4-9、虚拟局域网（vlan）" class="headerlink" title="4.9、虚拟局域网（vlan）"></a>4.9、虚拟局域网（vlan）</h2><p>&emsp;&emsp;局域网的结构是扁平化的，但是有时候希望局域网也有其结构，如果仅仅是通过交换机来分割层级是完成不了的，于是vlan以及三层交换机应时而出。</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/三层交换机示例.png" alt="三层交换机示例"></p>
<p>&emsp;&emsp;三层交换机是交换机与路由器的结合体，网络管理员可以将交换机的各个端口划分进不同的vlan中。不同的vlan间通过三层交换机的路由部件进行路由。同时多台三层交换机可以通过干线端口（trunk port）连接来扩大vlan的范围。</p>
<p>&emsp;&emsp;valn同时也需要链路层数据帧的报文格式的支持：</p>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/以太网帧扩展.png" alt="以太网帧扩展"></p>
<h2 id="4-7、比较链路层广播（二层广播）与网络层广播（三层广播）"><a href="#4-7、比较链路层广播（二层广播）与网络层广播（三层广播）" class="headerlink" title="4.7、比较链路层广播（二层广播）与网络层广播（三层广播）"></a>4.7、比较链路层广播（二层广播）与网络层广播（三层广播）</h2><h1 id="5、链路虚拟化：网络作为链路层"><a href="#5、链路虚拟化：网络作为链路层" class="headerlink" title="5、链路虚拟化：网络作为链路层"></a>5、链路虚拟化：网络作为链路层</h1><p>&emsp;&emsp;<font color="blue">链路虚拟化的意义是什么？</font></p>
<ul>
<li>多协议标签交换（MPLS）网络<ul>
<li>灵感来源于虚电路网络，<font color="red">根据入标签和目的地决定转发到哪一个端口以及出标签</font></li>
<li>作用在于查表的时候只需要查一个比较小的局部的表，而不需要查全部的表</li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/MPLS报文结构.png" alt="MPLS报文结构"></li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/MPLS转发示例.png" alt="MPLS转发示例"></li>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/MPLS网络结构.png" alt="MPLS网络结构"></li>
</ul>
</li>
<li>帧中继网络</li>
<li>ATM网络（Asynchronous Transfer Mode，异步传输模式）</li>
</ul>
<h1 id="6、数据中心网络"><a href="#6、数据中心网络" class="headerlink" title="6、数据中心网络"></a>6、数据中心网络</h1><p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/数据中心网络.png" alt="数据中心网络"></p>
<ol>
<li>负载均衡器（常被称为第四层交换机）<ul>
<li>均衡负载</li>
<li>提供类似NAT的功能，避免客户直接接触主机</li>
</ul>
</li>
<li>等级体系结构<ul>
<li>主机到主机容量受限问题：多条数据流并发时，主机间通信速率受限于交换机的链路速率</li>
</ul>
</li>
<li>数据中心网络的发展趋势<ul>
<li>全连接拓扑<ul>
<li><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/全连接拓扑数据中心.png" alt="全连接拓扑数据中心"></li>
</ul>
</li>
<li>模块化数据中心（MDC）</li>
</ul>
</li>
</ol>
<h1 id="7、Questions"><a href="#7、Questions" class="headerlink" title="7、Questions"></a>7、Questions</h1><ul>
<li><font color="blue">时钟漂移问题是哪个部分的内容？</font>

</li>
</ul>
<p><img src="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E9%93%BE%E8%B7%AF%E5%B1%82/Q1.png" alt="Q1"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/25/d.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%97%AE%E9%A2%98/" itemprop="url">d.计算机网络/问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-25T19:48:42+08:00">
                2021-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>（应用层）P2P一定要有服务器发送第一个副本吗？可以没有服务器吗？<ul>
<li>可以没有（把其中一个对等方看做服务器就OK了）。</li>
</ul>
</li>
<li>（应用层）如果两个后继同时退出呢？环形覆盖网络就发生了中断，这时候要怎么办？<ul>
<li>重新建立或者手动处理。</li>
</ul>
</li>
<li>（传输层）高层报文长度长于低层报文长度时怎么办？<ul>
<li>不管，在传输层眼中应用层报头与内容都是比特流，没有区别的，切片发送即可，应用层会负责解释拼接的报文的内容，比如确定长度。</li>
</ul>
</li>
<li>（传输层）将应用程序服务器端口是固定的，那么如果电脑上运行的两个应用程序其服务器端端口恰好重合了怎么办？<ul>
<li>两个进程的目标服务器的IP地址不一样</li>
</ul>
</li>
<li>（传输层rdt3.0）如果第一轮的ACK1在第二轮等待ACK1时到达而此时第二轮的ACK1尚未到达，这时就出错了，要如何处理这种情况呢？</li>
<li>（传输层GBN）计时器的数量是多少个？如果只有一个，那么是如何更新的？</li>
<li>（传输层GBN）接收方的expectedseqnum作用？</li>
<li>（传输层拥塞原因）拥塞情况1是因为传输过程发生比特差错吗？<font color="red">（情形1）分组的到达速率接近链路容量时，分组经历巨大的排队时延</font>。为什么？</li>
<li>（传输层）可靠数据传输原理中的窗口内分组编号与TCP的每个字节编号有什么联系与不同？窗口内分组编号存放在TCP哪里呢？是序号和确认号吗？</li>
<li>（传输层）可靠数据传输原理中的ACK与TCP中的ACK差别好大？</li>
<li>（传输层）TCP传数据时的序号与建立连接的序号又有什么关联？</li>
<li>（链路层）局域网在最开始的时候都是广播局域网吗？后来才变成了交换局域网？</li>
<li>（链路层）现在的交换局域网是否不需要多路访问协议？</li>
<li>（链路层）交换机的转发需要路径选择算法吗？</li>
<li>（链路层）在单纯的局域网中（没有IP地址），ARP是无法运行的，那么此时两台互不认识的终端如何通信？</li>
<li>（链路层）路由器的性质是收到广播包后不会转发到另一个端口，那么网络层广播怎么办？</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ryan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/liuxr98" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ryan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
